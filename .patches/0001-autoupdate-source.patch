From 42c4093cc917e665cb4c380d560036ce9a7fdaaf Mon Sep 17 00:00:00 2001
From: Alexey Morozov <alexey.morozov.is@gmail.com>
Date: Wed, 26 May 2021 18:43:28 +0300
Subject: [PATCH 1/9] autoupdate source

---
 ruby/autoupdate_autoupdate.c       | 1105 ++++++++++++++++++++++++++++
 ruby/autoupdate_exepath.c          |  164 +++++
 ruby/autoupdate_inflate.c          |    9 +
 ruby/autoupdate_tmpf.c             |  157 ++++
 ruby/autoupdate_utils.c            |  277 +++++++
 ruby/common.mk                     |    7 +-
 ruby/include/autoupdate.h          |   39 +
 ruby/include/autoupdate_internal.h |   49 ++
 8 files changed, 1806 insertions(+), 1 deletion(-)
 create mode 100644 ruby/autoupdate_autoupdate.c
 create mode 100644 ruby/autoupdate_exepath.c
 create mode 100644 ruby/autoupdate_inflate.c
 create mode 100644 ruby/autoupdate_tmpf.c
 create mode 100644 ruby/autoupdate_utils.c
 create mode 100644 ruby/include/autoupdate.h
 create mode 100644 ruby/include/autoupdate_internal.h

diff --git a/ruby/autoupdate_autoupdate.c b/ruby/autoupdate_autoupdate.c
new file mode 100644
index 00000000..9b6c73e6
--- /dev/null
+++ b/ruby/autoupdate_autoupdate.c
@@ -0,0 +1,1105 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+#include "zlib.h"
+
+#ifdef _WIN32
+
+#include <assert.h>
+#include <string.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <stdio.h>
+#include <conio.h>
+#include <stdint.h>
+#include <stdlib.h> /* exit */
+#include <wchar.h>
+
+int autoupdate(
+	int argc,
+	wchar_t *wargv[],
+	const char *host,
+	const char *port,
+	const char *path,
+	const char *current,
+	short force
+)
+{
+	WSADATA wsaData;
+
+	if (!force && !autoupdate_should_proceed()) {
+		return 1;
+	}
+
+	if (!force && !autoupdate_should_proceed_24_hours(argc, wargv, 0)) {
+		return 4;
+	}
+
+	// Initialize Winsock
+	int iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: WSAStartup failed with %d\n", iResult);
+		return 2;
+	}
+
+	struct addrinfo *result = NULL,
+		*ptr = NULL,
+		hints;
+
+	ZeroMemory(&hints, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_protocol = IPPROTO_TCP;
+
+	// Resolve the server address and port
+	iResult = getaddrinfo(host, port, &hints, &result);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: getaddrinfo failed with %d\n", iResult);
+		WSACleanup();
+		return 2;
+	}
+
+	SOCKET ConnectSocket = INVALID_SOCKET;
+
+	// Attempt to connect to the first address returned by
+	// the call to getaddrinfo
+	ptr = result;
+
+	// Create a SOCKET for connecting to server
+	ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,
+		ptr->ai_protocol);
+
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: Error at socket() with %d\n", WSAGetLastError());
+		freeaddrinfo(result);
+		WSACleanup();
+		return 2;
+	}
+
+	// Connect to server.
+	iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
+	if (iResult == SOCKET_ERROR) {
+		closesocket(ConnectSocket);
+		ConnectSocket = INVALID_SOCKET;
+	}
+	freeaddrinfo(result);
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %s\n", host, port);
+		WSACleanup();
+		return 2;
+	}
+	if (5 != send(ConnectSocket, "HEAD ", 5, 0) ||
+		strlen(path) != send(ConnectSocket, path, strlen(path), 0) ||
+		11 != send(ConnectSocket, " HTTP/1.0\r\n", 11, 0) ||
+		6 != send(ConnectSocket, "Host: ", 6, 0) ||
+		strlen(host) != send(ConnectSocket, host, strlen(host), 0) ||
+		4 != send(ConnectSocket, "\r\n\r\n", 4, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+
+	char response[1024 * 10 + 1]; // 10KB
+	int bytes, total;
+	total = sizeof(response) - 2;
+	long long received = 0;
+	do {
+		bytes = recv(ConnectSocket, response + received, total - received, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: recv failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		received += bytes;
+	} while (received < total);
+	if (received == total) {
+		fprintf(stderr, "Auto-update Failed: read causes buffer full\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+
+	// shutdown the connection for sending since no more data will be sent
+	// the client can still use the ConnectSocket for receiving data
+	iResult = shutdown(ConnectSocket, SD_SEND);
+	if (iResult == SOCKET_ERROR) {
+		fprintf(stderr, "Auto-update Failed: shutdown failed with %d\n", WSAGetLastError());
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+
+	assert(received < total);
+	size_t len = strlen(response);
+	short again_302 = 0;
+parse_location_header:
+	assert(len <= total);
+	char *new_line = NULL;
+	char *found = NULL;
+	size_t i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Location: ", 10)) {
+			found = response + i + 10;
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (!found) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Location header\n");
+		return 2;
+	}
+	if (!again_302) {
+		if (strstr(found, current)) {
+			/* Latest version confirmed. No need to update */
+			autoupdate_should_proceed_24_hours(argc, wargv, 1);
+			return 0;
+		} else {
+			fprintf(stderr, "Hint: to disable auto-update, run with environment variable CI=true\n");
+			fflush(stderr);
+		}
+	}
+
+	char *url = found;
+	fprintf(stderr, "Downloading update from %s\n", url);
+	fflush(stderr);
+
+	char *host2;
+	char *port2 = "80";
+	if (strlen(url) >= 8 && 0 == strncmp("https://", url, 8)) {
+		host2 = url + 8;
+	} else if (strlen(url) >= 7 && 0 == strncmp("http://", url, 7)) {
+		host2 = url + 7;
+	} else {
+		fprintf(stderr, "Auto-update Failed: failed to find http:// or https:// at the beginning of URL %s\n", url);
+		return 2;
+	}
+	char *found_slash = strchr(host2, '/');
+	char *request_path;
+	if (NULL == found_slash) {
+		request_path = "/";
+	} else {
+		request_path = found_slash;
+		*found_slash = 0;
+	}
+
+	result = NULL;
+	ptr = NULL;
+	ZeroMemory(&hints, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_protocol = IPPROTO_TCP;
+
+	// Resolve the server address and port
+	iResult = getaddrinfo(host2, port2, &hints, &result);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: getaddrinfo failed with %d\n", iResult);
+		WSACleanup();
+		return 2;
+	}
+
+	ConnectSocket = INVALID_SOCKET;
+
+	// Attempt to connect to the first address returned by
+	// the call to getaddrinfo
+	ptr = result;
+
+	// Create a SOCKET for connecting to server
+	ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
+
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: Error at socket() with %d\n", WSAGetLastError());
+		freeaddrinfo(result);
+		WSACleanup();
+		return 2;
+	}
+	// Connect to server.
+	iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
+	if (iResult == SOCKET_ERROR) {
+		closesocket(ConnectSocket);
+		ConnectSocket = INVALID_SOCKET;
+	}
+	freeaddrinfo(result);
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %s\n", host2, port2);
+		WSACleanup();
+		return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = '/';
+	}
+	if (4 != send(ConnectSocket, "GET ", 4, 0) ||
+		strlen(request_path) != send(ConnectSocket, request_path, strlen(request_path), 0) ||
+		11 != send(ConnectSocket, " HTTP/1.0\r\n", 11, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = 0;
+	}
+	if (6 != send(ConnectSocket, "Host: ", 6, 0) ||
+		strlen(host2) != send(ConnectSocket, host2, strlen(host2), 0) ||
+		4 != send(ConnectSocket, "\r\n\r\n", 4, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+
+	// Read the header
+	total = sizeof(response) - 2;
+	response[sizeof(response) - 1] = 0;
+	received = 0;
+	char *header_end = NULL;
+	do {
+		bytes = recv(ConnectSocket, response + received, total - received, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: recv failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		*(response + received + bytes) = 0;
+		header_end = strstr(response + received, "\r\n\r\n");
+		received += bytes;
+		if (header_end) {
+			break;
+		}
+	} while (received < total);
+	if (NULL == header_end) {
+		fprintf(stderr, "Auto-update Failed: failed to find the end of the response header\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	assert(received <= total);
+
+	// Possible new 302
+	if (received > 13 && (
+		0 == strncmp(response, "HTTP/1.1 302 ", 13) ||
+		0 == strncmp(response, "HTTP/1.0 302 ", 13))) {
+			len = received;
+			again_302 = 1;
+			goto parse_location_header;
+	}
+
+	// Parse the header
+	len = received;
+	assert(len <= total);
+	new_line = NULL;
+	long long found_length = -1;
+	i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Content-Length: ", 16)) {
+			found_length = atoll(response + i + 16);
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (-1 == found_length) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Content-Length header\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	if (0 == found_length) {
+		fprintf(stderr, "Auto-update Failed: found a Content-Length header of zero\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	assert(found_length > 0);
+	// Read the body
+	// header_end -> \r\n\r\n
+	assert(header_end);
+	assert(header_end + 4 <= response + received);
+	// put the rest of over-read content when reading header
+	size_t the_rest = response + received - (header_end + 4);
+	char *body_buffer = (char *)(malloc(found_length));
+	if (NULL == body_buffer) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	memcpy(body_buffer, (header_end + 4), the_rest);
+	char *body_buffer_ptr = body_buffer + the_rest;
+	char *body_buffer_end = body_buffer + found_length;
+	// read the remaining body
+	received = the_rest;
+	fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+	fflush(stderr);
+	while (received < found_length) {
+		size_t space = 100 * 1024;
+		if (space > body_buffer_end - body_buffer_ptr) {
+			space = body_buffer_end - body_buffer_ptr;
+		}
+		bytes = recv(ConnectSocket, body_buffer_ptr, space, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			free(body_buffer);
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			break;
+		}
+		received += bytes;
+		body_buffer_ptr += bytes;
+		fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+		fflush(stderr);
+	}
+	if (received != found_length) {
+		assert(received < found_length);
+		fprintf(stderr, "Auto-update Failed: prematurely reached EOF after reading %lld bytes\n", received);
+		closesocket(ConnectSocket);
+		WSACleanup();
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, "\n");
+	fflush(stderr);
+	// shutdown the connection for sending since no more data will be sent
+	// the client can still use the ConnectSocket for receiving data
+	iResult = shutdown(ConnectSocket, SD_SEND);
+	if (iResult == SOCKET_ERROR) {
+		fprintf(stderr, "Auto-update Failed: shutdown failed with %d\n", WSAGetLastError());
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	// Inflate to a file
+	fprintf(stderr, "Inflating");
+	fflush(stderr);
+	struct ZIPLocalFileHeader *h = (struct ZIPLocalFileHeader *)body_buffer;
+	if (!(0x04034b50 == h->signature && 8 == h->compressionMethod)) {
+		fprintf(stderr, "Auto-update Failed: We only support a zip file containing "
+			"one Deflate compressed file for the moment.\n"
+			"Pull requests are welcome on GitHub at "
+			"https://github.com/pmq20/libautoupdate\n");
+	}
+	// skip the Local File Header
+	unsigned full_length = found_length - sizeof(struct ZIPLocalFileHeader) - h->fileNameLength;
+	unsigned half_length = full_length / 2;
+	unsigned uncompLength = full_length;
+
+	/* windowBits is passed < 0 to tell that there is no zlib header.
+	* Note that in this case inflate *requires* an extra "dummy" byte
+	* after the compressed stream in order to complete decompression and
+	* return Z_STREAM_END.
+	*/
+	char* uncomp = (char*)calloc(sizeof(char), uncompLength + 1);
+	if (NULL == uncomp) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		free(body_buffer);
+		return 2;
+	}
+
+	z_stream strm;
+	strm.next_in = (Bytef *)(body_buffer + sizeof(struct ZIPLocalFileHeader) + h->fileNameLength);
+	strm.avail_in = found_length;
+	strm.total_out = 0;
+	strm.zalloc = Z_NULL;
+	strm.zfree = Z_NULL;
+
+	short done = 0;
+
+	if (inflateInit2(&strm, -MAX_WBITS) != Z_OK) {
+		free(uncomp);
+		free(body_buffer);
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		return 2;
+	}
+
+	while (!done) {
+		// If our output buffer is too small
+		if (strm.total_out >= uncompLength) {
+			// Increase size of output buffer
+			char* uncomp2 = (char*)calloc(sizeof(char), uncompLength + half_length + 1);
+			if (NULL == uncomp2) {
+				free(uncomp);
+				free(body_buffer);
+				fprintf(stderr, "Auto-update Failed: calloc failed\n");
+				return 2;
+			}
+			memcpy(uncomp2, uncomp, uncompLength);
+			uncompLength += half_length;
+			free(uncomp);
+			uncomp = uncomp2;
+		}
+
+		strm.next_out = (Bytef *)(uncomp + strm.total_out);
+		strm.avail_out = uncompLength - strm.total_out;
+
+		// Inflate another chunk.
+		int err = inflate(&strm, Z_SYNC_FLUSH);
+		if (err == Z_STREAM_END) {
+			done = 1;
+		}
+		else if (err != Z_OK) {
+			fprintf(stderr, "Auto-update Failed: inflate failed with %d\n", err);
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+	}
+
+	if (inflateEnd(&strm) != Z_OK) {
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+
+	wchar_t *tmpdir = autoupdate_tmpdir();
+	if (NULL == tmpdir) {
+		fprintf(stderr, "Auto-update Failed: no temporary folder found\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	/* Windows paths can never be longer than this. */
+	const size_t exec_path_len = 32768;
+	wchar_t exec_path[32768];
+	DWORD utf16_len = GetModuleFileNameW(NULL, exec_path, exec_path_len);
+	if (0 == utf16_len) {
+		fprintf(stderr, "Auto-update Failed: GetModuleFileNameW failed with GetLastError=%d\n", GetLastError());
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	if (tmpdir[0] != exec_path[0]) {
+		free((void*)(tmpdir));
+		tmpdir = wcsdup(exec_path);
+		wchar_t *backslash = wcsrchr(tmpdir, L'\\');
+		if (NULL == backslash) {
+			fprintf(stderr, "Auto-update Failed: Cannot find an approriate tmpdir with %S\n", tmpdir);
+			free((void*)(tmpdir));
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+		*backslash = 0;
+	}
+	wchar_t *tmpf = autoupdate_tmpf(tmpdir, "exe");
+	if (NULL == tmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	FILE *fp = _wfopen(tmpf, L"wb");
+	if (NULL == fp) {
+		fprintf(stderr, "Auto-update Failed: cannot open temporary file %S\n", tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, " to %S\n", tmpf);
+	size_t fwrite_ret = fwrite(uncomp, sizeof(char), strm.total_out, fp);
+	if (fwrite_ret != strm.total_out) {
+		fprintf(stderr, "Auto-update Failed: fwrite failed %S\n", tmpf);
+		fclose(fp);
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fclose(fp);
+	free(uncomp);
+	free(body_buffer);
+	// Backup
+	wchar_t *selftmpf = autoupdate_tmpf(tmpdir, "exe");
+	if (NULL == selftmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		return 2;
+	}
+	fprintf(stderr, "Moving the old version from %S to %S\n", exec_path, selftmpf);
+	BOOL ret = MoveFileExW(exec_path, selftmpf, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: MoveFileW failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 2;
+	}
+	// Move the new version into the original place
+	fprintf(stderr, "Moving the new version from %S to %S \n", tmpf, exec_path);
+	ret = MoveFileExW(tmpf, exec_path, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: MoveFileW failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 2;
+	}
+	// Restarting
+	fprintf(stderr, "Restarting...\n");
+	fflush(stderr);
+	STARTUPINFO si;
+	PROCESS_INFORMATION pi;
+	ZeroMemory(&si, sizeof(si));
+	si.cb = sizeof(si);
+	ZeroMemory(&pi, sizeof(pi));
+	ret = CreateProcess(
+		NULL,	     // No module name (use command line)
+		GetCommandLine(), // Command line
+		NULL,	     // Process handle not inheritable
+		NULL,	     // Thread handle not inheritable
+		FALSE,	    // Set handle inheritance to FALSE
+		0,		// No creation flags
+		NULL,	     // Use parent's environment block
+		NULL,	     // Use parent's starting directory 
+		&si,	      // Pointer to STARTUPINFO structure
+		&pi	       // Pointer to PROCESS_INFORMATION structure
+	);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: CreateProcess failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 3;
+	}
+	// Wait until child process exits.
+	WaitForSingleObject(pi.hProcess, INFINITE);
+	// Close process and thread handles. 
+	CloseHandle(pi.hProcess);
+	CloseHandle(pi.hThread);
+	fprintf(stderr, "Deleting %S\n", selftmpf);
+	fflush(stderr);
+	_wexeclp(L"cmd", L"cmd", L"/c", L"ping", L"127.0.0.1", L"-n", L"3", L">nul", L"&", L"del", selftmpf, NULL);
+	// we should never reach here
+	assert(0);
+	return 3;
+}
+
+#else
+
+#include <assert.h>
+#include <stdio.h> /* printf, sprintf */
+#include <stdlib.h> /* exit */
+#include <unistd.h> /* read, write, close */
+#include <string.h> /* memcpy, memset */
+#include <sys/socket.h> /* socket, connect */
+#include <netinet/in.h> /* struct sockaddr_in, struct sockaddr */
+#include <netdb.h> /* struct hostent, gethostbyname */
+#include <unistd.h>
+#include <sys/select.h>
+#include <limits.h>  /* PATH_MAX */
+#include <sys/stat.h> /* struct stat */
+#include <errno.h>
+
+int autoupdate(
+	int argc,
+	char *argv[],
+	const char *host,
+	uint16_t port,
+	const char *path,
+	const char *current,
+	short force
+)
+{
+	struct hostent *server;
+	struct sockaddr_in serv_addr;
+	int sockfd, bytes, total;
+	char response[1024 * 10 + 1]; // 10KB
+
+	if (!force && !autoupdate_should_proceed()) {
+		return 1;
+	}
+
+	if (!force && !autoupdate_should_proceed_24_hours(argc, argv, 0)) {
+		return 4;
+	}
+
+	sockfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		fprintf(stderr, "Auto-update Failed: socket creation failed\n");
+		return 2;
+	}
+	server = gethostbyname(host);
+	if (server == NULL) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: gethostbyname failed for %s\n", host);
+		return 2;
+	}
+	memset(&serv_addr, 0, sizeof(serv_addr));
+	serv_addr.sin_family = AF_INET;
+	serv_addr.sin_port = htons(port);
+	memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);
+	if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %d\n", host, port);
+		return 2;
+	}
+	if (5 != write(sockfd, "HEAD ", 5) ||
+		strlen(path) != write(sockfd, path, strlen(path)) ||
+		11 != write(sockfd, " HTTP/1.0\r\n", 11) ||
+		6 != write(sockfd, "Host: ", 6) ||
+		strlen(host) != write(sockfd, host, strlen(host)) ||
+		4 != write(sockfd, "\r\n\r\n", 4)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+	total = sizeof(response) - 2;
+	long long received = 0;
+	do {
+		bytes = read(sockfd, response + received, total - received);
+		if (bytes < 0) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		received += bytes;
+	} while (received < total);
+	if (received == total) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: read causes buffer full\n");
+		return 2;
+	}
+	close(sockfd);
+	assert(received < total);
+	size_t len = strlen(response);
+	short again_302 = 0;
+parse_location_header:
+	assert(len <= total);
+	char *new_line = NULL;
+	char *found = NULL;
+	size_t i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Location: ", 10)) {
+			found = response + i + 10;
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (!found) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Location header\n");
+		return 2;
+	}
+	if (!again_302) {
+		if (strstr(found, current)) {
+			/* Latest version confirmed. No need to update */
+			autoupdate_should_proceed_24_hours(argc, argv, 1);
+			return 0;
+		} else {
+			fprintf(stderr, "Hint: to disable auto-update, run with environment variable CI=true\n");
+			fflush(stderr);
+		}
+	}
+
+	char *url = found;
+	fprintf(stderr, "Downloading update from %s\n", url);
+	fflush(stderr);
+
+	char *host2;
+	uint16_t port2 = 80;
+	if (strlen(url) >= 8 && 0 == strncmp("https://", url, 8)) {
+		host2 = url + 8;
+	} else if (strlen(url) >= 7 && 0 == strncmp("http://", url, 7)) {
+		host2 = url + 7;
+	} else {
+		fprintf(stderr, "Auto-update Failed: failed to find http:// or https:// at the beginning of URL %s\n", url);
+		return 2;
+	}
+	char *found_slash = strchr(host2, '/');
+	char *request_path;
+	if (NULL == found_slash) {
+		request_path = "/";
+	} else {
+		request_path = found_slash;
+		*found_slash = 0;
+	}
+	sockfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		fprintf(stderr, "Auto-update Failed: socket creation failed\n");
+		return 2;
+	}
+	server = gethostbyname(host2);
+	if (server == NULL) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: gethostbyname failed for %s\n", host2);
+		return 2;
+	}
+	memset(&serv_addr, 0, sizeof(serv_addr));
+	serv_addr.sin_family = AF_INET;
+	serv_addr.sin_port = htons(port2);
+	memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);
+	if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %d\n", host2, port2);
+		return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = '/';
+	}
+	if (4 != write(sockfd, "GET ", 4) ||
+		strlen(request_path) != write(sockfd, request_path, strlen(request_path)) ||
+		11 != write(sockfd, " HTTP/1.0\r\n", 11)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = 0;
+	}
+	if (6 != write(sockfd, "Host: ", 6) ||
+		strlen(host2) != write(sockfd, host2, strlen(host2)) ||
+		4 != write(sockfd, "\r\n\r\n", 4)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+
+	// Read the header
+	total = sizeof(response) - 2;
+	response[sizeof(response) - 1] = 0;
+	received = 0;
+	char *header_end = NULL;
+	do {
+		bytes = read(sockfd, response + received, total - received);
+		if (bytes < 0) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		*(response + received + bytes) = 0;
+		header_end = strstr(response + received, "\r\n\r\n");
+		received += bytes;
+		if (header_end) {
+			break;
+		}
+	} while (received < total);
+	if (NULL == header_end) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: failed to find the end of the response header\n");
+		return 2;
+	}
+	assert(received <= total);
+
+	// Possible new 302
+	if (received > 13 && (
+		0 == strncmp(response, "HTTP/1.1 302 ", 13) ||
+		0 == strncmp(response, "HTTP/1.0 302 ", 13))) {
+			len = received;
+			again_302 = 1;
+			goto parse_location_header;
+	}
+
+	// Parse the header
+	len = received;
+	assert(len <= total);
+	new_line = NULL;
+	long long found_length = -1;
+	i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Content-Length: ", 16)) {
+			found_length = atoll(response + i + 16);
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (-1 == found_length) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: failed to find a Content-Length header\n");
+		return 2;
+	}
+	if (0 == found_length) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: found a Content-Length header of zero\n");
+		return 2;
+	}
+	assert(found_length > 0);
+	// Read the body
+	// header_end -> \r\n\r\n
+	assert(header_end);
+	assert(header_end + 4 <= response + received);
+	// put the rest of over-read content when reading header
+	size_t the_rest = response + received - (header_end + 4);
+	char *body_buffer = (char *)(malloc(found_length));
+	if (NULL == body_buffer) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		return 2;
+	}
+	memcpy(body_buffer, (header_end + 4), the_rest);
+	char *body_buffer_ptr = body_buffer + the_rest;
+	char *body_buffer_end = body_buffer + found_length;
+	// read the remaining body
+	received = the_rest;
+	fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+	fflush(stderr);
+	while (received < found_length) {
+		size_t space = 100 * 1024;
+		if (space > body_buffer_end - body_buffer_ptr) {
+			space = body_buffer_end - body_buffer_ptr;
+		}
+		bytes = read(sockfd, body_buffer_ptr, space);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			free(body_buffer);
+			close(sockfd);
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			break;
+		}
+		received += bytes;
+		body_buffer_ptr += bytes;
+		fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+		fflush(stderr);
+	}
+	if (received != found_length) {
+		assert(received < found_length);
+		fprintf(stderr, "Auto-update Failed: prematurely reached EOF after reading %lld bytes\n", received);
+		close(sockfd);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, "\n");
+	fflush(stderr);
+	close(sockfd);
+	// Inflate to a file
+	fprintf(stderr, "Inflating");
+	fflush(stderr);
+	unsigned full_length = found_length;
+	unsigned half_length = found_length / 2;
+	unsigned uncompLength = full_length;
+	char* uncomp = (char*) calloc( sizeof(char), uncompLength );
+	if (NULL == uncomp) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		free(body_buffer);
+		return 2;
+	}
+
+	z_stream strm;
+	strm.next_in = (Bytef *)body_buffer;
+	strm.avail_in = found_length;
+	strm.total_out = 0;
+	strm.zalloc = Z_NULL;
+	strm.zfree = Z_NULL;
+	
+	short done = 0;
+
+	if (inflateInit2(&strm, (16+MAX_WBITS)) != Z_OK) {
+		free(uncomp);
+		free(body_buffer);
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		return 2;
+	}
+	
+	while (!done) {
+		// If our output buffer is too small
+		if (strm.total_out >= uncompLength ) {
+			// Increase size of output buffer
+			char* uncomp2 = (char*) calloc( sizeof(char), uncompLength + half_length );
+			if (NULL == uncomp2) {
+				free(uncomp);
+				free(body_buffer);
+				fprintf(stderr, "Auto-update Failed: calloc failed\n");
+				return 2;
+			}
+			memcpy( uncomp2, uncomp, uncompLength );
+			uncompLength += half_length ;
+			free( uncomp );
+			uncomp = uncomp2 ;
+		}
+		
+		strm.next_out = (Bytef *) (uncomp + strm.total_out);
+		strm.avail_out = uncompLength - strm.total_out;
+		
+		// Inflate another chunk.
+		int err = inflate(&strm, Z_SYNC_FLUSH);
+		if (err == Z_STREAM_END) {
+			done = 1;
+		}
+		else if (err != Z_OK)  {
+			fprintf(stderr, "Auto-update Failed: inflate failed with %d\n", err);
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+	}
+
+	if (inflateEnd (&strm) != Z_OK) {
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+
+	char *tmpdir = autoupdate_tmpdir();
+	if (NULL == tmpdir) {
+		fprintf(stderr, "Auto-update Failed: no temporary folder found\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	char *tmpf = autoupdate_tmpf(tmpdir, NULL);
+	if (NULL == tmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	FILE *fp = fopen(tmpf, "wb");
+	if (NULL == fp) {
+		fprintf(stderr, "Auto-update Failed: cannot open temporary file %s\n", tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, " to %s\n", tmpf);
+	size_t fwrite_ret = fwrite(uncomp, sizeof(char), strm.total_out, fp);
+	if (fwrite_ret != strm.total_out) {
+		fprintf(stderr, "Auto-update Failed: fwrite failed %s\n", tmpf);
+		fclose(fp);
+		unlink(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fclose(fp);
+	free(uncomp);
+	free(body_buffer);
+	// chmod
+	size_t exec_path_len = 2 * PATH_MAX;
+	char* exec_path = (char*)(malloc(exec_path_len));
+	if (NULL == exec_path) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory allocating exec_path\n");
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	if (autoupdate_exepath(exec_path, &exec_path_len) != 0) {
+		if (!argv[0]) {
+			fprintf(stderr, "Auto-update Failed: missing argv[0]\n");
+			free((void*)(tmpdir));
+			free((void*)(tmpf));
+			unlink(tmpf);
+			return 2;
+		}
+		assert(strlen(argv[0]) < 2 * PATH_MAX);
+		memcpy(exec_path, argv[0], strlen(argv[0]));
+	}
+	struct stat current_st;
+	int ret = stat(exec_path, &current_st);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: stat failed for %s\n", exec_path);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	ret = chmod(tmpf, current_st.st_mode | S_IXUSR);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: chmod failed for %s\n", tmpf);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	// Move the new version into the original place
+	fprintf(stderr, "Moving the new version from %s to %s\n", tmpf, exec_path);
+	ret = rename(tmpf, exec_path);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: failed calling rename %s to %s\n", tmpf, exec_path);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	fprintf(stderr, "Restarting...\n");
+	ret = execv(exec_path, argv);
+	// we should not reach this point
+	fprintf(stderr, "Auto-update Failed: execv failed with %d (errno %d)\n", ret, errno);
+	free(exec_path);
+	free((void*)(tmpdir));
+	free((void*)(tmpf));
+	unlink(tmpf);
+	return 3;
+}
+
+#endif // _WIN32
diff --git a/ruby/autoupdate_exepath.c b/ruby/autoupdate_exepath.c
new file mode 100644
index 00000000..ca1fdde3
--- /dev/null
+++ b/ruby/autoupdate_exepath.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+/*
+ * autoupdate_exepath is derived from uv_exepath of libuv.
+ * libuv is licensed for use as follows:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+
+#ifdef _WIN32
+
+#include <assert.h>
+#include <direct.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <wchar.h>
+#include <windows.h>
+
+int autoupdate_exepath(char* buffer, size_t* size_ptr) {
+  int utf8_len, utf16_buffer_len, utf16_len;
+  WCHAR* utf16_buffer;
+  int err;
+
+  if (buffer == NULL || size_ptr == NULL || *size_ptr == 0) {
+    return -1;
+  }
+
+  if (*size_ptr > 32768) {
+    /* Windows paths can never be longer than this. */
+    utf16_buffer_len = 32768;
+  } else {
+    utf16_buffer_len = (int) *size_ptr;
+  }
+
+  utf16_buffer = (WCHAR*) malloc(sizeof(WCHAR) * utf16_buffer_len);
+  if (!utf16_buffer) {
+    return -1;
+  }
+
+  /* Get the path as UTF-16. */
+  utf16_len = GetModuleFileNameW(NULL, utf16_buffer, utf16_buffer_len);
+  if (utf16_len <= 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  /* utf16_len contains the length, *not* including the terminating null. */
+  utf16_buffer[utf16_len] = L'\0';
+
+  /* Convert to UTF-8 */
+  utf8_len = WideCharToMultiByte(CP_UTF8,
+                                 0,
+                                 utf16_buffer,
+                                 -1,
+                                 buffer,
+                                 (int) *size_ptr,
+                                 NULL,
+                                 NULL);
+  if (utf8_len == 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  free(utf16_buffer);
+
+  /* utf8_len *does* include the terminating null at this point, but the */
+  /* returned size shouldn't. */
+  *size_ptr = utf8_len - 1;
+  return 0;
+
+ error:
+  free(utf16_buffer);
+  return -1;
+}
+
+#endif
+
+#ifdef __linux__
+#include <unistd.h>
+
+int autoupdate_exepath(char* buffer, size_t* size) {
+  ssize_t n;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  n = *size - 1;
+  if (n > 0)
+    n = readlink("/proc/self/exe", buffer, n);
+
+  if (n == -1)
+    return -1;
+
+  buffer[n] = '\0';
+  *size = n;
+
+  return 0;
+}
+#endif
+
+#ifdef __APPLE__
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <mach-o/dyld.h>
+#include <limits.h>  // PATH_MAX
+
+int autoupdate_exepath(char* buffer, size_t* size) {
+  /* realpath(exepath) may be > PATH_MAX so double it to be on the safe side. */
+  char abspath[PATH_MAX * 2 + 1];
+  char exepath[PATH_MAX + 1];
+  uint32_t exepath_size;
+  size_t abspath_size;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  exepath_size = sizeof(exepath);
+  if (_NSGetExecutablePath(exepath, &exepath_size))
+    return -1;
+
+  if (realpath(exepath, abspath) != abspath)
+    return -1;
+
+  abspath_size = strlen(abspath);
+  if (abspath_size == 0)
+    return -1;
+
+  *size -= 1;
+  if (*size > abspath_size)
+    *size = abspath_size;
+
+  memcpy(buffer, abspath, *size);
+  buffer[*size] = '\0';
+
+  return 0;
+}
+#endif
diff --git a/ruby/autoupdate_inflate.c b/ruby/autoupdate_inflate.c
new file mode 100644
index 00000000..a65d5255
--- /dev/null
+++ b/ruby/autoupdate_inflate.c
@@ -0,0 +1,9 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
diff --git a/ruby/autoupdate_tmpf.c b/ruby/autoupdate_tmpf.c
new file mode 100644
index 00000000..54aea3e8
--- /dev/null
+++ b/ruby/autoupdate_tmpf.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+
+#include <time.h>
+#include <stdlib.h>
+
+#ifdef _WIN32
+
+#include <Windows.h>
+#include <Shlwapi.h>
+#include <process.h>
+#include <assert.h>
+
+wchar_t* autoupdate_tmpdir()
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	DWORD length;
+
+	length = GetEnvironmentVariableW(L"TEMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"TMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"SystemRoot", squash_win32_buf, squash_win32_buf_sz);
+	if (!length) {
+		length = GetEnvironmentVariableW(L"windir", squash_win32_buf, squash_win32_buf_sz);
+	}
+	if (length) {
+		if (length + 5 >= squash_win32_buf_sz) {
+			return NULL;
+		}
+		squash_win32_buf[length] = L'\\';
+		squash_win32_buf[length + 1] = L't';
+		squash_win32_buf[length + 2] = L'e';
+		squash_win32_buf[length + 3] = L'm';
+		squash_win32_buf[length + 4] = L'p';
+		squash_win32_buf[length + 5] = 0;
+		length += 5;
+		goto out;
+	}
+	return NULL;
+out:
+	if (length >= 2 && L'\\' == squash_win32_buf[length - 1] && L':' != squash_win32_buf[length - 2]) {
+		squash_win32_buf[length - 1] = 0;
+		length -= 1;
+	}
+	return wcsdup(squash_win32_buf);
+}
+
+wchar_t* autoupdate_tmpf(wchar_t *tmpdir, const char *ext_name)
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	size_t curlen, size_ret;
+	int try_cnt = 0;
+	srand(time(NULL) * getpid());
+	squash_win32_buf[squash_win32_buf_sz] = 0;
+	while (try_cnt < 3) {
+		squash_win32_buf[0] = 0;
+		assert(0 == wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), tmpdir, squash_win32_buf_sz - wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L"\\libautoupdate-", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		// up to 33 characters for _itoa
+		if (squash_win32_buf_sz - wcslen(squash_win32_buf) <= 33) {
+			return NULL;
+		}
+		_itow(rand(), squash_win32_buf + wcslen(squash_win32_buf), 10);
+		if (ext_name) {
+			wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L".", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		}
+		if (ext_name) {
+			curlen = wcslen(squash_win32_buf);
+			size_ret = mbstowcs((wchar_t*)(squash_win32_buf) + curlen, ext_name, squash_win32_buf_sz - curlen);
+			if ((size_t)-1 == size_ret) {
+				return NULL;
+			}
+			*((wchar_t*)(squash_win32_buf) + curlen + size_ret) = 0;
+		}
+		if (!PathFileExistsW(squash_win32_buf)) {
+			return wcsdup(squash_win32_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+
+#else
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+char* autoupdate_tmpdir()
+{
+	char *try_try;
+	size_t length;
+	try_try = getenv("TMPDIR");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TEMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = "/tmp";
+out:
+	try_try = strdup(try_try);
+	length = strlen(try_try);
+	if (length >= 2 && '/' == try_try[length - 1]) {
+		try_try[length - 1] = 0;
+	}
+	return try_try;
+}
+
+char* autoupdate_tmpf(char *tmpdir, const char *ext_name)
+{
+	const int squash_buf_sz = 32767;
+	char squash_buf[squash_buf_sz + 1];
+	int ret, try_cnt = 0;
+	struct stat statbuf;
+
+	srand(time(NULL) * getpid());
+	while (try_cnt < 3) {
+		if (ext_name) {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libautoupdate-%d.%s", tmpdir, rand(), ext_name);
+		} else {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libautoupdate-%d", tmpdir, rand());
+		}
+		if (-1 == ret) {
+			return NULL;
+		}
+		if (-1 == stat(squash_buf, &statbuf)) {
+			return strdup(squash_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+
+#endif // _WIN32
diff --git a/ruby/autoupdate_utils.c b/ruby/autoupdate_utils.c
new file mode 100644
index 00000000..4887fc0c
--- /dev/null
+++ b/ruby/autoupdate_utils.c
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+#include <assert.h>
+
+#ifdef _WIN32
+
+#include <Windows.h>
+#include <wchar.h>
+#include <Shlobj.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <string.h>
+#include <time.h>
+#include <limits.h>
+
+short autoupdate_should_proceed()
+{
+	TCHAR lpBuffer[32767 + 1];
+	if (0 == GetEnvironmentVariable("CI", lpBuffer, 32767)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+#else
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <string.h>
+#include <time.h>
+#include <limits.h>
+
+short autoupdate_should_proceed()
+{
+	if (NULL == getenv("CI")) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+#endif // _WIN32
+
+#ifdef _WIN32
+short autoupdate_should_proceed_24_hours(int argc, wchar_t *wargv[], short will_write)
+{
+	const KNOWNFOLDERID rfid = FOLDERID_Profile;
+	PWSTR ppszPath = NULL;
+	HRESULT hret;
+	wchar_t filepath[2 * 32768];
+	const wchar_t *filename = L"\\.libautoupdate";
+	size_t exec_path_len = 2 * 32768;
+	char exec_path[2 * 32768];
+#else
+short autoupdate_should_proceed_24_hours(int argc, char *argv[], short will_write)
+{
+	char *filepath = NULL;
+	const char *filename = "/.libautoupdate";
+	size_t exec_path_len = 2 * PATH_MAX;
+	char exec_path[2 * PATH_MAX];
+	struct passwd *pw;
+	const char *homedir;
+#endif // _WIN32
+	short has_written = 0;
+	time_t time_now;
+	long item_time;
+	char *item_string = NULL;
+	char *item_space;
+	char *cursor;
+	char *string = NULL;
+	char *string0 = NULL;
+	long fsize;
+	FILE *f = NULL;
+	int ret;
+	size_t size_t_ret;
+	
+	if (autoupdate_exepath(exec_path, &exec_path_len) != 0) {
+#ifdef _WIN32
+		goto exit;
+#else
+		if (!argv[0]) {
+			goto exit;
+		}
+		assert(strlen(argv[0]) < 2 * PATH_MAX);
+		memcpy(exec_path, argv[0], strlen(argv[0]));
+#endif
+	}
+
+	time_now = time(NULL);
+	if ((time_t)-1 == time_now) {
+		goto exit;
+	}
+#ifdef _WIN32
+	hret = SHGetKnownFolderPath(
+		&rfid,
+		0,
+		NULL,
+		&ppszPath
+	);
+	if (S_OK != hret) {
+		goto exit;
+	}
+	memcpy(filepath, ppszPath, wcslen(ppszPath) * sizeof(wchar_t));
+	memcpy(filepath + wcslen(ppszPath), filename, wcslen(filename) * sizeof(wchar_t));
+	filepath[wcslen(ppszPath) + wcslen(filename)] = 0;
+	f = _wfopen(filepath, L"rb");
+#else
+	pw = getpwuid(getuid());
+	if (NULL == pw) {
+		goto exit;
+	}
+	homedir = pw->pw_dir;
+	if (NULL == homedir) {
+		goto exit;
+	}
+	filepath = malloc(strlen(homedir) + strlen(filename) + 1);
+	if (NULL == filepath) {
+		goto exit;
+	}
+	memcpy(filepath, homedir, strlen(homedir));
+	memcpy(filepath + strlen(homedir), filename, strlen(filename));
+	filepath[strlen(homedir) + strlen(filename)] = 0;
+	f = fopen(filepath, "rb");
+#endif // _WIN32
+	if (NULL == f) {
+		if (will_write) {
+			string0 = NULL;
+			goto write;
+		} else {
+			goto exit;
+		}
+	}
+	ret = fseek(f, 0, SEEK_END);
+	if (0 != ret) {
+		goto exit;
+	}
+	fsize = ftell(f);
+	if (fsize <= 0) {
+		goto exit;
+	}
+	ret = fseek(f, 0, SEEK_SET);
+	if (0 != ret) {
+		goto exit;
+	}
+	
+	string = malloc(fsize + 1);
+	if (NULL == string) {
+		goto exit;
+	}
+	string0 = string;
+	size_t_ret = fread(string, fsize, 1, f);
+	if (1 != size_t_ret) {
+		goto exit;
+	}
+	string[fsize] = 0;
+	ret = fclose(f);
+	if (0 != ret) {
+		goto exit;
+	}
+	f = NULL;
+	string[fsize] = 0;
+	while (string < string0 + fsize) {
+		cursor = strchr(string, '\n');
+		if (!cursor) {
+			if (will_write) {
+				string0 = NULL;
+				goto write;
+			} else {
+				goto exit;
+			}
+		}
+		*cursor = 0;
+		item_space = strchr(string, ' ');
+		if (!item_space) {
+			goto exit;
+		}
+		*item_space = 0;
+		item_time = atol(string);
+		item_string = item_space + 1;
+		if (exec_path_len == cursor - item_string && 0 == memcmp(item_string, exec_path, exec_path_len)) {
+			if (will_write) {
+				if (item_time >= 1000000000 && time_now >= 1000000000) {
+					has_written = 1;
+#ifdef _WIN32
+					_ltoa(time_now, string, 10);
+#else
+					ret = sprintf(string, "%ld", time_now);
+#endif // _WIN32
+					string[10] = ' ';
+					*cursor = '\n';
+					break;
+				}
+			} else if (time_now - item_time < 24 * 3600) {
+				return 0;
+			}
+		}
+		*item_space = ' ';
+		*cursor = '\n';
+		string = cursor + 1;
+	}
+write:
+	if (will_write) {
+#ifdef _WIN32
+		f = _wfopen(filepath, L"wb");
+#else
+		f = fopen(filepath, "wb");
+#endif // _WIN32
+		if (NULL == f) {
+			goto exit;
+		}
+		if (string0) {
+			ret = fwrite(string0, fsize, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+		}
+		if (!has_written) {
+			char writting[20];
+#ifdef _WIN32
+			_ltoa(time_now, writting, 10);
+			ret = fwrite(writting, strlen(writting), 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+			ret = fwrite(" ", 1, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+#else
+			ret = sprintf(writting, "%ld ", time_now);
+			ret = fwrite(writting, strlen(writting), 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+#endif // _WIN32
+			ret = fwrite(exec_path, exec_path_len, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+			ret = fwrite("\n", 1, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	if (f) {
+		fclose(f);
+	}
+	if (string0) {
+		free(string0);
+	}
+#ifdef _WIN32
+	if (ppszPath) {
+		CoTaskMemFree(ppszPath);
+	}
+#else
+	if (filepath) {
+		free(filepath);
+	}
+#endif
+	return 1;
+}
diff --git a/ruby/common.mk b/ruby/common.mk
index 3f4bcf6c..c00e674f 100644
--- a/ruby/common.mk
+++ b/ruby/common.mk
@@ -68,7 +68,12 @@ ENC_MK        = enc.mk
 MAKE_ENC      = -f $(ENC_MK) V="$(V)" UNICODE_HDR_DIR="$(UNICODE_HDR_DIR)" \
 		RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS)
 
-COMMONOBJS    = array.$(OBJEXT) \
+COMMONOBJS    = autoupdate_autoupdate.$(OBJEXT) \
+		autoupdate_exepath.$(OBJEXT) \
+		autoupdate_inflate.$(OBJEXT) \
+		autoupdate_tmpf.$(OBJEXT) \
+		autoupdate_utils.$(OBJEXT) \
+		array.$(OBJEXT) \
 		bignum.$(OBJEXT) \
 		class.$(OBJEXT) \
 		compar.$(OBJEXT) \
diff --git a/ruby/include/autoupdate.h b/ruby/include/autoupdate.h
new file mode 100644
index 00000000..359f36ea
--- /dev/null
+++ b/ruby/include/autoupdate.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef AUTOUPDATE_H_8C141CA2
+#define AUTOUPDATE_H_8C141CA2
+
+#ifdef _WIN32
+
+#include <wchar.h>
+int autoupdate(
+	int argc,
+	wchar_t *wargv[],
+	const char *host,
+	const char *port,
+	const char *path,
+	const char *current,
+	short force
+);
+
+#else
+
+#include <stdint.h>
+int autoupdate(
+	int argc,
+	char *argv[],
+	const char *host,
+	uint16_t port,
+	const char *path,
+	const char *current,
+	short force
+);
+
+#endif // _WIN32
+
+#endif /* end of include guard: AUTOUPDATE_H_8C141CA2 */
diff --git a/ruby/include/autoupdate_internal.h b/ruby/include/autoupdate_internal.h
new file mode 100644
index 00000000..7e992d3d
--- /dev/null
+++ b/ruby/include/autoupdate_internal.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef AUTOUPDATE_INTERNAL_H_A40E122A
+#define AUTOUPDATE_INTERNAL_H_A40E122A
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef _WIN32
+
+#define PACK( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop) )
+
+PACK(
+	struct ZIPLocalFileHeader
+{
+	uint32_t signature;
+	uint16_t versionNeededToExtract; // unsupported
+	uint16_t generalPurposeBitFlag; // unsupported
+	uint16_t compressionMethod;
+	uint16_t lastModFileTime;
+	uint16_t lastModFileDate;
+	uint32_t crc32;
+	uint32_t compressedSize;
+	uint32_t uncompressedSize;
+	uint16_t fileNameLength;
+	uint16_t extraFieldLength; // unsupported
+});
+
+wchar_t* autoupdate_tmpdir();
+wchar_t* autoupdate_tmpf(wchar_t *tmpdir, const char *ext_name);
+short autoupdate_should_proceed_24_hours(int argc, wchar_t *wargv[], short will_write);
+
+#else
+
+char* autoupdate_tmpdir();
+char* autoupdate_tmpf(char *tmpdir, const char *ext_name);
+short autoupdate_should_proceed_24_hours(int argc, char *argv[], short will_write);
+	
+#endif // _WIN32
+
+short autoupdate_should_proceed();
+int autoupdate_exepath(char* buffer, size_t* size);
+
+#endif /* end of include guard: AUTOUPDATE_INTERNAL_H_A40E122A */
-- 
2.24.3 (Apple Git-128)

