From 0de8950dcd79fcdc53f7ed8bf0ad72ba81885884 Mon Sep 17 00:00:00 2001
From: Alexey Morozov <alexey.morozov.is@gmail.com>
Date: Wed, 26 May 2021 20:05:44 +0300
Subject: [PATCH 6/8] enclose io usage

---
 ruby/dir.c                        | 23 ++++++++++++++---
 ruby/dln.c                        |  4 +++
 ruby/ext/openssl/ossl_x509store.c |  9 +++++++
 ruby/file.c                       |  4 +++
 ruby/io.c                         |  4 +++
 ruby/lib/rubygems/path_support.rb | 16 ++++++++++++
 ruby/process.c                    |  4 +++
 ruby/ruby.c                       | 17 ++++++++++++
 ruby/tool/mkconfig.rb             | 12 +++++++++
 ruby/util.c                       |  4 +++
 ruby/win32/file.c                 |  4 +++
 ruby/win32/win32.c                | 43 +++++++++++++++++++++++++++++--
 12 files changed, 138 insertions(+), 6 deletions(-)

diff --git a/ruby/dir.c b/ruby/dir.c
index 6a926f43..600c47e8 100644
--- a/ruby/dir.c
+++ b/ruby/dir.c
@@ -127,6 +127,10 @@ char *strchr(char*,char);
 # define NORMALIZE_UTF8PATH 0
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #if NORMALIZE_UTF8PATH
 #include <sys/param.h>
 #include <sys/mount.h>
@@ -144,8 +148,10 @@ need_normalization(DIR *dirp, const char *path)
     u_int32_t attrbuf[SIZEUP32(fsobj_tag_t)];
     struct attrlist al = {ATTR_BIT_MAP_COUNT, 0, ATTR_CMN_OBJTAG,};
 #   if defined HAVE_FGETATTRLIST
+    if (squash_find_entry(dirp)) { return FALSE; }
     int ret = fgetattrlist(dirfd(dirp), &al, attrbuf, sizeof(attrbuf), 0);
 #   else
+    if (enclose_io_is_path(path)) { return FALSE; }
     int ret = getattrlist(path, &al, attrbuf, sizeof(attrbuf), 0);
 #   endif
     if (!ret) {
@@ -567,8 +573,13 @@ dir_initialize(int argc, VALUE *argv, VALUE dir)
 	else if (e == EIO) {
 	    u_int32_t attrbuf[1];
 	    struct attrlist al = {ATTR_BIT_MAP_COUNT, 0};
-	    if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW) == 0) {
-		dp->dir = opendir_without_gvl(path);
+        if (enclose_io_is_path(path)) {
+            struct stat buf;
+            if (0 == squash_lstat(enclose_io_fs, path, &buf)) {
+                dp->dir = opendir_without_gvl(path);
+            }
+        } else if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW) == 0) {
+            dp->dir = opendir_without_gvl(path);
 	    }
 	}
 #endif
@@ -1780,9 +1791,13 @@ is_case_sensitive(DIR *dirp, const char *path)
     const uint32_t mask = VOL_CAP_FMT_CASE_SENSITIVE;
 
 #   if defined HAVE_FGETATTRLIST
+    if (squash_find_entry(dirp)) { return 1; }
+
     if (fgetattrlist(dirfd(dirp), &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW))
 	return -1;
 #   else
+    if (enclose_io_is_path(path)) { return 1; }
+
     if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW))
 	return -1;
 #   endif
@@ -2402,7 +2417,7 @@ glob_helper(
 		    break;
 		}
 #if USE_NAME_ON_FS == USE_NAME_ON_FS_REAL_BASENAME
-		if ((*cur)->type == ALPHA) {
+		if ((*cur)->type == ALPHA && !enclose_io_if(buf)) {
 		    buf = replace_real_basename(buf, pathlen + (dirsep != 0), enc,
 						IF_NORMALIZE_UTF8PATH(1)+0,
 						flags, &new_pathtype);
@@ -3355,7 +3370,7 @@ rb_dir_s_empty_p(VALUE obj, VALUE dirname)
     path = RSTRING_PTR(dirname);
 
 #if defined HAVE_GETATTRLIST && defined ATTR_DIR_ENTRYCOUNT
-    {
+    if (!enclose_io_is_path(path)) {
 	u_int32_t attrbuf[SIZEUP32(fsobj_tag_t)];
 	struct attrlist al = {ATTR_BIT_MAP_COUNT, 0, ATTR_CMN_OBJTAG,};
 	if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), 0) != 0)
diff --git a/ruby/dln.c b/ruby/dln.c
index c40cbfc6..27dd701e 100644
--- a/ruby/dln.c
+++ b/ruby/dln.c
@@ -116,6 +116,10 @@ dln_loaderror(const char *format, ...)
 #define isdirsep(x) ((x) == '/')
 #endif
 
+// ======= [Enclose.io Hack start] =========
+#include "enclose_io.h"
+// ======= [Enclose.io Hack end] =========
+
 static size_t
 init_funcname_len(const char **file)
 {
diff --git a/ruby/ext/openssl/ossl_x509store.c b/ruby/ext/openssl/ossl_x509store.c
index 61543d44..34d76a3c 100644
--- a/ruby/ext/openssl/ossl_x509store.c
+++ b/ruby/ext/openssl/ossl_x509store.c
@@ -331,6 +331,10 @@ ossl_x509store_add_file(VALUE self, VALUE file)
  *
  * Adds _path_ as the hash dir to be looked up by the store.
  */
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io_prelude.h"
+#include "enclose_io_common.h"
+// --------- [Enclose.io Hack end] ---------
 static VALUE
 ossl_x509store_add_path(VALUE self, VALUE dir)
 {
@@ -344,6 +348,11 @@ ossl_x509store_add_path(VALUE self, VALUE dir)
     GetX509Store(self, store);
     lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());
     if(lookup == NULL) ossl_raise(eX509StoreError, NULL);
+    // --------- [Enclose.io Hack start] ---------
+    #ifdef RUBY_PACKER_RUBYC_2ND_PASS
+      path = enclose_io_ifextract(path, NULL);
+    #endif
+    // --------- [Enclose.io Hack end] ---------
     if(X509_LOOKUP_add_dir(lookup, path, X509_FILETYPE_PEM) != 1){
         ossl_raise(eX509StoreError, NULL);
     }
diff --git a/ruby/file.c b/ruby/file.c
index c46377b9..739a02ce 100644
--- a/ruby/file.c
+++ b/ruby/file.c
@@ -97,6 +97,10 @@ int flock(int, int);
 #define lstat stat
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 /* define system APIs */
 #ifdef _WIN32
 #include "win32/file.h"
diff --git a/ruby/io.c b/ruby/io.c
index 868756ff..3fff8689 100644
--- a/ruby/io.c
+++ b/ruby/io.c
@@ -168,6 +168,10 @@ off_t __syscall(quad_t number, ...);
 #  define RUBY_PIPE_NONBLOCK_DEFAULT    (0)
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 VALUE rb_cIO;
 VALUE rb_eEOFError;
 VALUE rb_eIOError;
diff --git a/ruby/lib/rubygems/path_support.rb b/ruby/lib/rubygems/path_support.rb
index 6a5d180a..db4b4b58 100644
--- a/ruby/lib/rubygems/path_support.rb
+++ b/ruby/lib/rubygems/path_support.rb
@@ -26,6 +26,13 @@ class Gem::PathSupport
   def initialize(env)
     @home = env["GEM_HOME"] || Gem.default_dir
 
+    # --------- [Enclose.io Hack start] ---------
+    # WE DO NOT ACCEPT OUTSIDE GEM PATHS
+    unless env['RUBY_PACKER_RUBYC_1ST_PASS']
+      @home = Gem.default_dir unless 0 == @home.index('/__enclose_io_memfs__')
+    end
+    # --------- [Enclose.io Hack end] ---------
+
     if File::ALT_SEPARATOR
       @home = @home.gsub(File::ALT_SEPARATOR, File::SEPARATOR)
     end
@@ -34,6 +41,15 @@ class Gem::PathSupport
 
     @path = split_gem_path env["GEM_PATH"], @home
 
+    # --------- [Enclose.io Hack start] ---------
+    # WE DO NOT ACCEPT OUTSIDE GEM PATHS
+    unless env['RUBY_PACKER_RUBYC_1ST_PASS']
+      @path.keep_if do |x|
+        0 == x.index('/__enclose_io_memfs__')
+      end
+    end
+    # --------- [Enclose.io Hack end] ---------
+
     @spec_cache_dir = env["GEM_SPEC_CACHE"] || Gem.default_spec_cache_dir
 
     @spec_cache_dir = @spec_cache_dir.dup.tap(&Gem::UNTAINT)
diff --git a/ruby/process.c b/ruby/process.c
index 530f3208..3a1b2129 100644
--- a/ruby/process.c
+++ b/ruby/process.c
@@ -94,6 +94,10 @@ int initgroups(const char *, rb_gid_t);
 #define open	rb_w32_uopen
 #endif
 
+// --------- [Enclose.IO Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.IO Hack end] ---------
+
 #if defined(HAVE_TIMES) || defined(_WIN32)
 static VALUE rb_cProcessTms;
 #endif
diff --git a/ruby/ruby.c b/ruby/ruby.c
index 7903f583..b9bb0db9 100644
--- a/ruby/ruby.c
+++ b/ruby/ruby.c
@@ -54,6 +54,10 @@
 
 #include "mjit.h"
 
+// --------- [Enclose.IO Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.IO Hack end] ---------
+
 void Init_ruby_description(void);
 
 #ifndef HAVE_STDLIB_H
@@ -584,6 +588,9 @@ ruby_init_loadpath(void)
     VALUE load_path, archlibdir = 0;
     ID id_initial_load_path_mark;
     const char *paths = ruby_initial_load_paths;
+// --------- [Enclose.IO Hack start] ---------
+#ifndef RUBY_PACKER_RUBYC_BUILD_PASS2
+// --------- [Enclose.IO Hack end] ---------
 #if defined LOAD_RELATIVE
 #if !defined ENABLE_MULTIARCH
 # define RUBY_ARCH_PATH ""
@@ -653,6 +660,16 @@ ruby_init_loadpath(void)
 #define RUBY_RELATIVE(path, len) rubylib_path_new((path), (len))
 #define PREFIX_PATH() RUBY_RELATIVE(ruby_exec_prefix, exec_prefix_len)
 #endif
+// --------- [Enclose.IO Hack start] ---------
+#else // ifndef RUBY_PACKER_RUBYC_BUILD_PASS2
+#define PREFIX_PATH() rb_str_new("/__enclose_io_memfs__", 21)
+#ifdef _WIN32
+#define RUBY_RELATIVE(path, len) rb_str_buf_cat(rb_str_buf_cat(rb_str_buf_new(21+(len)), "/__enclose_io_memfs__", 21), (path), (len))
+#else // ifdef _WIN32
+#define RUBY_RELATIVE(path, len) rubylib_path_new((path), (len))
+#endif // ifdef _WIN32
+#endif // ifndef RUBY_PACKER_RUBYC_BUILD_PASS2
+// --------- [Enclose.IO Hack end] ---------
     rb_gc_register_address(&ruby_prefix_path);
     ruby_prefix_path = PREFIX_PATH();
     OBJ_FREEZE_RAW(ruby_prefix_path);
diff --git a/ruby/tool/mkconfig.rb b/ruby/tool/mkconfig.rb
index 05ecb815..3e1e2b24 100755
--- a/ruby/tool/mkconfig.rb
+++ b/ruby/tool/mkconfig.rb
@@ -127,6 +127,18 @@ File.foreach "config.status" do |line|
       val = '"$(SDKROOT)"'+val if /darwin/ =~ arch
     end
     v = "  CONFIG[\"#{name}\"] #{eq} #{val}\n"
+
+    # --------- [Enclose.IO Hack start] ---------
+    if ENV['ENCLOSE_IO_RUBYC_2ND_PASS']
+      [
+        "  CONFIG[\"prefix\"] #{eq} ",
+        "  CONFIG[\"RUBY_EXEC_PREFIX\"] #{eq} "
+      ].each do |v_head_comp|
+        v = "#{v[0...(v_head_comp.length)]}'/__enclose_io_memfs__'\n" if v_head_comp == v[0...(v_head_comp.length)]
+      end
+    end
+    # --------- [Enclose.IO Hack end] ---------
+
     if fast[name]
       v_fast << v
     else
diff --git a/ruby/util.c b/ruby/util.c
index aa8e7ef3..a7b231a9 100644
--- a/ruby/util.c
+++ b/ruby/util.c
@@ -30,6 +30,10 @@
 const char ruby_hexdigits[] = "0123456789abcdef0123456789ABCDEF";
 #define hexdigit ruby_hexdigits
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 unsigned long
 ruby_scan_oct(const char *start, size_t len, size_t *retlen)
 {
diff --git a/ruby/win32/file.c b/ruby/win32/file.c
index 9d213700..070a1bd1 100644
--- a/ruby/win32/file.c
+++ b/ruby/win32/file.c
@@ -10,6 +10,10 @@
 #include <shlwapi.h>
 #include "win32/file.h"
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #ifndef INVALID_FILE_ATTRIBUTES
 # define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
 #endif
diff --git a/ruby/win32/win32.c b/ruby/win32/win32.c
index 247ac918..8c4c52fc 100644
--- a/ruby/win32/win32.c
+++ b/ruby/win32/win32.c
@@ -56,6 +56,11 @@
 #include "id.h"
 #include "internal.h"
 #include "encindex.h"
+
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #define isdirsep(x) ((x) == '/' || (x) == '\\')
 
 #if defined _MSC_VER && _MSC_VER <= 1200
@@ -846,6 +851,12 @@ static int w32_cmdvector(const WCHAR *, char ***, UINT, rb_encoding *);
 void
 rb_w32_sysinit(int *argc, char ***argv)
 {
+// --------- [Enclose.IO Hack start] ---------
+    int new_argc;
+    char **new_argv;
+		UINT cp = CP_UTF8;
+    size_t i;
+// --------- [Enclose.IO Hack end] ---------
 #if RUBY_MSVCRT_VERSION >= 80
     static void set_pioinfo_extra(void);
 
@@ -863,6 +874,25 @@ rb_w32_sysinit(int *argc, char ***argv)
     //
     *argc = w32_cmdvector(GetCommandLineW(), argv, CP_UTF8, &OnigEncodingUTF_8);
 
+// --------- [Enclose.IO Hack start] ---------
+#ifdef RUBY_PACKER_ENTRANCE
+    new_argc = *argc;
+    new_argv = *argv;
+    if (NULL == getenv("RUBY_PACKER_USE_ORIGINAL_RUBY")) {
+        new_argv = (char **)malloc( (*argc + 1) * sizeof(char *));
+        assert(new_argv);
+        new_argv[0] = (*argv)[0];
+        new_argv[1] = RUBY_PACKER_ENTRANCE;
+        for (i = 1; i < *argc; ++i) {
+            new_argv[2 + i - 1] = (*argv)[i];
+        }
+        new_argc = *argc + 1;
+
+        *argc = new_argc;
+        *argv = new_argv;
+    }
+#endif
+// --------- [Enclose.IO Hack end] ---------
     //
     // Now set up the correct time stuff
     //
@@ -1864,6 +1894,9 @@ w32_cmdvector(const WCHAR *cmd, char ***vec, UINT cp, rb_encoding *enc)
 	curr = (NtCmdLineElement *)calloc(sizeof(NtCmdLineElement), 1);
 	if (!curr) goto do_nothing;
 	curr->str = rb_w32_wstr_to_mbstr(cp, base, len, &curr->len);
+// --------- [Enclose.IO Hack start] ---------
+    if (curr->str && (curr->str = realloc(curr->str, curr->len + 1))) { curr->str[curr->len] = '\0'; }
+// --------- [Enclose.IO Hack end] ---------
 	curr->flags |= NTMALLOC;
 
 	if (globbing && (tail = cmdglob(curr, cmdtail, cp, enc))) {
@@ -6226,7 +6259,10 @@ w32_wopen(const WCHAR *file, int oflag, int pmode)
 
     share_delete = oflag & O_SHARE_DELETE ? FILE_SHARE_DELETE : 0;
     oflag &= ~O_SHARE_DELETE;
-    if ((oflag & O_TEXT) || !(oflag & O_BINARY)) {
+// --------- [Enclose.IO Hack start] ---------
+// TODO: https://github.com/pmq20/ruby-packer/issues/118
+    if (enclose_io_if_w(file) || (oflag & O_TEXT) || !(oflag & O_BINARY)) {
+// --------- [Enclose.IO Hack end] ---------
 	fd = _wopen(file, oflag, pmode);
 	if (fd == -1) {
 	    switch (errno) {
@@ -6999,7 +7035,10 @@ rb_w32_read(int fd, void *buf, size_t size)
 	return -1;
     }
 
-    if (_osfile(fd) & FTEXT) {
+// --------- [Enclose.IO Hack start] ---------
+// TODO: https://github.com/pmq20/ruby-packer/issues/118
+    if (SQUASH_VALID_VFD(fd) || (_osfile(fd) & FTEXT)) {
+// --------- [Enclose.IO Hack end] ---------
 	return _read(fd, buf, size);
     }
 
-- 
2.24.3 (Apple Git-128)

