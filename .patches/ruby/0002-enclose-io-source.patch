From cd5d4d771ca139cdfd9e132d26e9b2a89e2e9d15 Mon Sep 17 00:00:00 2001
From: Alexey Morozov <alexey.morozov.is@gmail.com>
Date: Wed, 26 May 2021 18:46:16 +0300
Subject: [PATCH 2/8] enclose io source

---
 ruby/common.mk            |    4 +-
 ruby/enclose_io.h         |   17 +
 ruby/enclose_io_common.h  |  372 ++++++++++
 ruby/enclose_io_prelude.h |   19 +
 ruby/enclose_io_unix.c    | 1435 +++++++++++++++++++++++++++++++++++++
 ruby/enclose_io_unix.h    |   48 ++
 ruby/enclose_io_win32.c   | 1325 ++++++++++++++++++++++++++++++++++
 ruby/enclose_io_win32.h   |   74 ++
 ruby/enclose_io_winapi.h  |  246 +++++++
 9 files changed, 3539 insertions(+), 1 deletion(-)
 create mode 100644 ruby/enclose_io.h
 create mode 100644 ruby/enclose_io_common.h
 create mode 100644 ruby/enclose_io_prelude.h
 create mode 100644 ruby/enclose_io_unix.c
 create mode 100644 ruby/enclose_io_unix.h
 create mode 100644 ruby/enclose_io_win32.c
 create mode 100644 ruby/enclose_io_win32.h
 create mode 100644 ruby/enclose_io_winapi.h

diff --git a/ruby/common.mk b/ruby/common.mk
index d1e6e0a7..8c1f865e 100644
--- a/ruby/common.mk
+++ b/ruby/common.mk
@@ -101,6 +101,8 @@ COMMONOBJS    = squash_cache.$(OBJEXT) \
 		squash_table.$(OBJEXT) \
 		squash_traverse.$(OBJEXT) \
 		squash_util.$(OBJEXT) \
+		enclose_io_unix.$(OBJEXT) \
+		enclose_io_win32.$(OBJEXT) \
 		array.$(OBJEXT) \
 		ast.$(OBJEXT) \
 		bignum.$(OBJEXT) \
@@ -371,7 +373,7 @@ $(LIBRUBY_EXTS):
 
 $(STATIC_RUBY)$(EXEEXT): $(MAINOBJ) $(DLDOBJS) $(EXTOBJS) $(LIBRUBY_A)
 	$(Q)$(RM) $@
-	$(PURIFY) $(CC) $(MAINOBJ) $(DLDOBJS) $(LIBRUBY_A) $(MAINLIBS) $(EXTLIBS) $(LIBS) $(OUTFLAG)$@ $(LDFLAGS) $(XLDFLAGS)
+	$(PURIFY) $(CC) $(MAINOBJ) $(DLDOBJS) $(LIBRUBY_A) $(MAINLIBS) $(EXTLIBS) $(LIBS) $(OUTFLAG)$@ $(LDFLAGS) $(XLDFLAGS) enclose_io_memfs.$(OBJEXT)
 
 ruby.imp: $(COMMONOBJS)
 	$(Q){ \
diff --git a/ruby/enclose_io.h b/ruby/enclose_io.h
new file mode 100644
index 00000000..741205de
--- /dev/null
+++ b/ruby/enclose_io.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef RUBY_PACKER_H_999BC1DA
+#define RUBY_PACKER_H_999BC1DA
+
+#include "enclose_io_prelude.h"
+#include "enclose_io_common.h"
+#include "enclose_io_win32.h"
+#include "enclose_io_unix.h"
+
+#endif
diff --git a/ruby/enclose_io_common.h b/ruby/enclose_io_common.h
new file mode 100644
index 00000000..5bab7423
--- /dev/null
+++ b/ruby/enclose_io_common.h
@@ -0,0 +1,372 @@
+/*
+ * Copyright (c) 2017 - 2020 Minqi Pan <pmq2001@gmail.com>
+ *                           Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_COMMON_H_39323079
+#define ENCLOSE_IO_COMMON_H_39323079
+
+#include "squash.h"
+
+#ifndef __USE_XOPEN_EXTENDED
+#define __USE_XOPEN_EXTENDED
+#endif
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <limits.h> /* PATH_MAX */
+
+#ifdef __linux__
+#include <linux/limits.h> /* PATH_MAX */
+#endif
+
+#ifdef _WIN32
+#include <direct.h>
+#include <Shlwapi.h>
+#else
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <unistd.h>
+#include <ftw.h>
+#include <dirent.h>
+#include <dlfcn.h>
+#endif
+
+extern sqfs *enclose_io_fs;
+extern sqfs_path enclose_io_cwd;
+
+#define ENCLOSE_IO_PP_NARG(...) \
+    ENCLOSE_IO_PP_NARG_(__VA_ARGS__,ENCLOSE_IO_PP_RSEQ_N())
+#define ENCLOSE_IO_PP_NARG_(...) \
+    ENCLOSE_IO_PP_ARG_N(__VA_ARGS__)
+#define ENCLOSE_IO_PP_ARG_N( \
+     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
+    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
+    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
+    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
+    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
+    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
+    _61,_62,_63,  N, ...) N
+#define ENCLOSE_IO_PP_RSEQ_N() \
+    63,62,61,60,                   \
+    59,58,57,56,55,54,53,52,51,50, \
+    49,48,47,46,45,44,43,42,41,40, \
+    39,38,37,36,35,34,33,32,31,30, \
+    29,28,27,26,25,24,23,22,21,20, \
+    19,18,17,16,15,14,13,12,11,10, \
+     9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+
+short enclose_io_is_path(char *pathname);
+short enclose_io_is_path_w(wchar_t *pathname);
+short enclose_io_is_relative_w(wchar_t *pathname);
+
+#define ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(PATH, RETURN1, RETURN2) \
+	if (mkdir_workdir) { \
+		sqfs_path mkdir_workdir_expanded; \
+		char *mkdir_workdir_expanded_head; \
+		size_t mkdir_workdir_len; \
+		size_t memcpy_len; \
+		struct stat mkdir_workdir_buf; \
+		mkdir_workdir_len = strlen(mkdir_workdir); \
+		memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len); \
+		memcpy_len = strlen(PATH); \
+		if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) { \
+			memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len; \
+		} \
+		memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (PATH), memcpy_len); \
+		mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0'; \
+		mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope); \
+		if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) { \
+			memmove(mkdir_workdir_expanded_head, mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope), strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1); \
+			if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) { \
+				return(RETURN2); \
+			} \
+		} \
+	} \
+	return(RETURN1)
+
+#define ENCLOSE_IO_GEN_EXPANDED_NAME(path)	\
+			enclose_io_cwd_len = strlen(enclose_io_cwd); \
+			memcpy(enclose_io_expanded, enclose_io_cwd, enclose_io_cwd_len); \
+			memcpy_len = strlen(path); \
+			if (SQUASHFS_PATH_LEN - enclose_io_cwd_len < memcpy_len) { memcpy_len = SQUASHFS_PATH_LEN - enclose_io_cwd_len; } \
+			memcpy(&enclose_io_expanded[enclose_io_cwd_len], (path), memcpy_len); \
+			enclose_io_expanded[enclose_io_cwd_len + memcpy_len] = '\0'
+
+//TODO maybe use WideCharToMultiByte
+#define W_ENCLOSE_IO_PATH_CONVERT(path) \
+			enclose_io_converted = (char *)enclose_io_converted_storage; \
+			enclose_io_converted_length = wcstombs(enclose_io_converted_storage, (path), SQUASHFS_PATH_LEN); \
+			if ((size_t)-1 == enclose_io_converted_length) { enclose_io_converted_length = 0; } \
+			enclose_io_converted[enclose_io_converted_length] = '\0'; \
+			if (strnlen(enclose_io_converted_storage, 4) >= 4 && (0 == strncmp(enclose_io_converted_storage, "\\\\?\\", 4) || 0 == strncmp(enclose_io_converted_storage, "//?/", 4))) { \
+				if (strnlen(enclose_io_converted_storage, 6) >= 6 && ':' == enclose_io_converted_storage[5]) { \
+					enclose_io_converted += 6; \
+				} else { \
+					enclose_io_converted += 4; \
+				} \
+			} else if (strnlen(enclose_io_converted_storage, 3) >= 3 && (0 == strncmp(enclose_io_converted_storage + 1, ":\\", 2) || 0 == strncmp(enclose_io_converted_storage + 1, ":/", 2))) { \
+				enclose_io_converted += 2; \
+			} \
+			for (enclose_io_i = enclose_io_converted; *enclose_io_i; enclose_io_i++) { \
+				if ('\\' == *enclose_io_i) { *enclose_io_i = '/'; } \
+			}
+
+#define ENCLOSE_IO_SET_LAST_ERROR do { \
+			if (ENOMEM == errno) { \
+				SetLastError(ERROR_NOT_ENOUGH_MEMORY); \
+                                _doserrno = ERROR_NOT_ENOUGH_MEMORY; \
+			} else if (ENOENT == errno) { \
+				SetLastError(ERROR_FILE_NOT_FOUND); \
+                                _doserrno = ERROR_FILE_NOT_FOUND; \
+			} else if (EBADF == errno) { \
+				SetLastError(ERROR_INVALID_HANDLE); \
+                                _doserrno = ERROR_INVALID_HANDLE; \
+			} else if (ENAMETOOLONG == errno) { \
+				SetLastError(ERROR_BUFFER_OVERFLOW); \
+                                _doserrno = ERROR_BUFFER_OVERFLOW; \
+			} else { \
+				SetLastError(ERROR_INVALID_FUNCTION); \
+                                _doserrno = ERROR_INVALID_FUNCTION; \
+			} \
+		} while (0)
+
+int enclose_io_exepath(char* buffer, size_t* size);
+int enclose_io_dos_return(int statement);
+short enclose_io_if(const char* path);
+SQUASH_OS_PATH enclose_io_ifextract(const char* path, const char* ext_name);
+void enclose_io_chdir_helper(const char *path);
+int enclose_io_chdir(const char *path);
+char *enclose_io_getcwd(char *buf, size_t size);
+char *enclose_io_getwd(char *buf);
+int enclose_io_stat(const char *path, struct stat *buf);
+int enclose_io_fstat(int fildes, struct stat *buf);
+int enclose_io_open(int nargs, const char *pathname, int flags, ...);
+int enclose_io_openat(int fd, int nargs, const char *pathname, int flags, ...);
+int enclose_io_close(int fildes);
+ssize_t enclose_io_read(int fildes, void *buf, size_t nbyte);
+off_t enclose_io_lseek(int fildes, off_t offset, int whence);
+
+#ifdef _WIN32
+
+#include "enclose_io_winapi.h"
+
+short enclose_io_if_w(const wchar_t* path);
+int enclose_io__open(const char *pathname, int flags);
+int enclose_io__wopen(const wchar_t *pathname, int flags, int mode);
+int enclose_io__wmkdir(wchar_t* pathname);
+int enclose_io_open_osfhandle(intptr_t osfhandle, int flags);
+intptr_t enclose_io_get_osfhandle(int fd);
+int enclose_io_wchdir(const wchar_t *path);
+wchar_t *enclose_io_wgetcwd(wchar_t *buf, size_t size);
+int enclose_io_fstati64(int fildes, struct _stati64 *buf);
+__int64 enclose_io_lseeki64(int fildes, __int64 offset, int whence);
+
+HANDLE
+EncloseIOCreateFileW(
+	LPCWSTR lpFileName,
+	DWORD dwDesiredAccess,
+	DWORD dwShareMode,
+	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+	DWORD dwCreationDisposition,
+	DWORD dwFlagsAndAttributes,
+	HANDLE hTemplateFile
+);
+
+NTSTATUS
+EncloseIOpNtQueryDirectoryFile(
+	HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+);
+
+BOOL
+EncloseIOCloseHandle(
+	HANDLE hObject
+);
+
+DWORD
+EncloseIOGetFileAttributesW(
+    LPCWSTR lpFileName
+);
+
+BOOL
+EncloseIOGetFileAttributesExW(
+    LPCWSTR lpFileName,
+    GET_FILEEX_INFO_LEVELS fInfoLevelId,
+    LPVOID lpFileInformation
+);
+
+NTSTATUS
+EncloseIOpNtQueryInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass);
+
+NTSTATUS
+EncloseIOpNtQueryVolumeInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass);
+
+BOOL
+EncloseIOReadFile(
+	HANDLE       hFile,
+	LPVOID       lpBuffer,
+	DWORD        nNumberOfBytesToRead,
+	LPDWORD      lpNumberOfBytesRead,
+	LPOVERLAPPED lpOverlapped
+);
+
+BOOL
+EncloseIOGetHandleInformation(
+    HANDLE hObject,
+    LPDWORD lpdwFlags
+);
+
+DWORD
+EncloseIOGetFileType(
+        HANDLE hFile
+);
+
+HANDLE
+EncloseIOFindFirstFileW(
+        LPCWSTR lpFileName,
+        LPWIN32_FIND_DATAW lpFindFileData
+);
+
+BOOL
+EncloseIOFindNextFileW(
+        HANDLE hFindFile,
+        LPWIN32_FIND_DATAW lpFindFileData
+);
+
+BOOL
+EncloseIOFindClose(
+        HANDLE hFindFile
+);
+
+BOOL
+EncloseIODeviceIoControl(
+        HANDLE hDevice,
+        DWORD dwIoControlCode,
+        LPVOID lpInBuffer,
+        DWORD nInBufferSize,
+        LPVOID lpOutBuffer,
+        DWORD nOutBufferSize,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped
+);
+
+HANDLE
+EncloseIOCreateIoCompletionPort(
+        HANDLE FileHandle,
+        HANDLE ExistingCompletionPort,
+        ULONG_PTR CompletionKey,
+        DWORD NumberOfConcurrentThreads
+);
+
+BOOL
+EncloseIOReadDirectoryChangesW(
+        HANDLE hDirectory,
+        LPVOID lpBuffer,
+        DWORD nBufferLength,
+        BOOL bWatchSubtree,
+        DWORD dwNotifyFilter,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped,
+        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
+);
+
+HMODULE
+EncloseIOLoadLibraryExW(
+	LPCWSTR lpLibFileName,
+	HANDLE hFile,
+	DWORD dwFlags
+);
+
+BOOL
+EncloseIOCreateProcessW(
+	LPCWSTR lpApplicationName,
+	LPWSTR lpCommandLine,
+	LPSECURITY_ATTRIBUTES lpProcessAttributes,
+	LPSECURITY_ATTRIBUTES lpThreadAttributes,
+	BOOL bInheritHandles,
+	DWORD dwCreationFlags,
+	LPVOID lpEnvironment,
+	LPCWSTR lpCurrentDirectory,
+	LPSTARTUPINFOW lpStartupInfo,
+	LPPROCESS_INFORMATION lpProcessInformation
+);
+	
+BOOL
+EncloseIOSetCurrentDirectoryW(
+	LPCWSTR lpPathName
+);
+
+DWORD
+EncloseIOGetCurrentDirectoryW(
+	DWORD nBufferLength,
+	LPWSTR lpBuffer
+);
+
+DWORD
+EncloseIOGetFullPathNameW(
+	LPCWSTR lpFileName,
+	DWORD nBufferLength,
+	LPWSTR lpBuffer,
+	LPWSTR* lpFilePart
+);
+
+BOOL
+EncloseIOGetFileInformationByHandle(
+	HANDLE hFile,
+	LPBY_HANDLE_FILE_INFORMATION lpFileInformation
+);
+
+#else // ifdef _WIN32
+int enclose_io_lstat(const char *path, struct stat *buf);
+ssize_t enclose_io_readlink(const char *path, char *buf, size_t bufsize);
+DIR * enclose_io_opendir(const char *filename);
+DIR * enclose_io_fdopendir(int fd);
+int enclose_io_closedir(DIR *dirp);
+struct SQUASH_DIRENT * enclose_io_readdir(DIR *dirp);
+long enclose_io_telldir(DIR *dirp);
+void enclose_io_seekdir(DIR *dirp, long loc);
+void enclose_io_rewinddir(DIR *dirp);
+int enclose_io_dirfd(DIR *dirp);
+int enclose_io_scandir(const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int(*select)(const struct SQUASH_DIRENT *),
+	int(*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **));
+ssize_t enclose_io_pread(int d, void *buf, size_t nbyte, off_t offset);
+ssize_t enclose_io_readv(int d, const struct iovec *iov, int iovcnt);
+void* enclose_io_dlopen(const char* path, int mode);
+int enclose_io_access(const char *path, int mode);
+int enclose_io_mkdir(const char *path, mode_t mode);
+int enclose_io_execv(const char *path, char *const argv[]);
+
+#endif // ifdef _WIN32
+
+#endif
diff --git a/ruby/enclose_io_prelude.h b/ruby/enclose_io_prelude.h
new file mode 100644
index 00000000..133d44f1
--- /dev/null
+++ b/ruby/enclose_io_prelude.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_PRELUDE_H_E46A560C
+#define ENCLOSE_IO_PRELUDE_H_E46A560C
+
+#ifdef _WIN32
+#define WINDOWS_H_A80B5674
+typedef unsigned short sqfs_mode_t;
+typedef uint32_t sqfs_id_t;
+typedef DWORD64 sqfs_off_t;
+#endif // _WIN32
+
+#endif /* end of include guard: ENCLOSE_IO_PRELUDE_H_E46A560C */
diff --git a/ruby/enclose_io_unix.c b/ruby/enclose_io_unix.c
new file mode 100644
index 00000000..7ee07b77
--- /dev/null
+++ b/ruby/enclose_io_unix.c
@@ -0,0 +1,1435 @@
+/*
+ * Copyright (c) 2017 - 2020 Minqi Pan <pmq2001@gmail.com>
+ *                           Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "enclose_io_common.h"
+
+#ifdef _WIN32
+#include <assert.h>
+#include <direct.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <wchar.h>
+#include <windows.h>
+#define MAXPATHLEN 4096
+#define mode_t unsigned int
+#endif
+
+#ifdef __linux__
+#include <unistd.h>
+#endif
+
+#ifdef __APPLE__
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <mach-o/dyld.h>
+#include <limits.h>  // PATH_MAX
+#endif
+
+sqfs *enclose_io_fs;
+sqfs_path enclose_io_cwd; /* must end with a slash */
+SQUASH_OS_PATH generic_mkdir_workdir = NULL;
+char *mkdir_workdir = NULL; /* must NOT end with a slash */
+char *enclose_io_mkdir_scope = "/__enclose_io_memfs__"; /* must NOT end with a slash */
+
+#ifdef _WIN32
+#include <shellapi.h>
+static void mkdir_workdir_halt_rm(const wchar_t *sPath)
+{
+	SHFILEOPSTRUCTW fileop;
+	size_t len = wcslen(sPath);
+	wchar_t pFrom[MAX_PATH * 2];
+
+	if (len > MAX_PATH) {
+		return;
+	}
+	wcscpy(pFrom, sPath);
+	pFrom[len] = 0;
+	pFrom[len + 1] = 0;
+	
+	fileop.hwnd = NULL;
+	fileop.wFunc = FO_DELETE;
+	fileop.pFrom = pFrom;
+	fileop.pTo = NULL;
+	fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;
+	fileop.fAnyOperationsAborted = FALSE;
+	fileop.lpszProgressTitle = NULL;
+	fileop.hNameMappings = NULL;
+
+	SHFileOperationW(&fileop);
+}
+#else
+static int mkdir_workdir_halt_rm(const char *arg1, const struct stat *ptr, int flag, struct FTW *ftwarg)
+{
+	if (FTW_D == flag || FTW_DNR == flag || FTW_DP == flag) {
+		rmdir(arg1);
+	} else {
+		unlink(arg1);
+	}
+}
+#endif
+
+static void mkdir_workdir_halt()
+{
+#ifdef _WIN32
+	mkdir_workdir_halt_rm(generic_mkdir_workdir);
+#else
+	nftw(mkdir_workdir, mkdir_workdir_halt_rm, 20, FTW_PHYS | FTW_MOUNT | FTW_DEPTH);
+#endif
+}
+
+static char * enclose_io_mkdir_workdir()
+{
+	if (NULL == mkdir_workdir) {
+		MUTEX_LOCK(&squash_global_mutex);
+		if (NULL == mkdir_workdir) {
+			generic_mkdir_workdir = squash_tmpf(squash_tmpdir(), NULL);
+			if (NULL == generic_mkdir_workdir) {
+				mkdir_workdir = NULL;
+				return NULL;
+			}
+#ifdef _WIN32
+			mkdir_workdir = malloc(MAX_PATH * 3);
+			if (NULL == mkdir_workdir) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if ((size_t)-1 == wcstombs(mkdir_workdir, generic_mkdir_workdir, MAX_PATH)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if (mkdir(mkdir_workdir)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if (atexit(mkdir_workdir_halt)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+#else
+			mkdir_workdir = generic_mkdir_workdir;
+			if (mkdir(mkdir_workdir, S_IRWXU)) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if (atexit(mkdir_workdir_halt)) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+#endif
+		}
+		MUTEX_UNLOCK(&squash_global_mutex);
+	}
+	return mkdir_workdir;
+}
+
+static int enclose_io_mkdir_consult(char *path, mode_t mode) {
+	int ret;
+	char *head = NULL;
+	char *p = NULL;
+	char *p_left = NULL;
+	struct stat buf;
+	char *path2;
+
+	while (strlen(path) - 1 >= 0 && '/' == path[strlen(path) - 1]) {
+		path[strlen(path) - 1] = 0;
+	}
+
+	head = strstr(path, enclose_io_mkdir_scope);
+	if (NULL == head || '/' != head[strlen(enclose_io_mkdir_scope)]) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	for (p = head + strlen(enclose_io_mkdir_scope) + 1; *p; p++) {
+		if (*p == '/') {
+			*p = 0;
+			if (0 == squash_stat(enclose_io_fs, head, &buf) && S_ISDIR(buf.st_mode)) {
+				path2 = strdup(path);
+				if (NULL == path2) {
+					return -1;
+				} else {
+					memmove(
+						path2 + (head-path),
+						path2 + (head-path) + strlen(enclose_io_mkdir_scope),
+						strlen(path2 + (head-path) + strlen(enclose_io_mkdir_scope)) + 1
+					);
+#ifdef _WIN32
+					mkdir(path2);
+#else
+					mkdir(path2, mode);
+#endif
+					free(path2);
+				}
+				*p = '/';
+			} else {
+				*p = '/';
+				break;
+			}
+		}
+	}
+	memmove(
+		head,
+		head + strlen(enclose_io_mkdir_scope),
+		strlen(head + strlen(enclose_io_mkdir_scope)) + 1
+	);
+#ifdef _WIN32
+	return mkdir(path);
+#else
+	return mkdir(path, mode);
+#endif
+}
+
+int enclose_io_mkdir(const char *path, mode_t mode)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		struct stat buf;
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		int ret;
+		int ret_inner;
+		const char* workdir;
+		const char* workdir_path;
+
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ret = squash_stat(enclose_io_fs, enclose_io_expanded, &buf);
+		workdir = enclose_io_mkdir_workdir();
+		if (NULL == workdir) {
+			errno = ENOENT;
+			return -1;
+		}
+		workdir_path = malloc(strlen(workdir) + strlen(enclose_io_expanded) + 1);
+		if (NULL == workdir_path) {
+			errno = ENOMEM;
+			return -1;
+		}
+		strcpy(workdir_path, workdir);
+		strcat(workdir_path, enclose_io_expanded);
+		ret_inner = enclose_io_mkdir_consult(workdir_path, mode);
+		free(workdir_path);
+		if (0 == ret) {
+			errno = EEXIST;
+			return -1;
+		} else {
+			return ret_inner;
+		}
+	} else if (enclose_io_is_path(path)) {
+		struct stat buf;
+		int ret;
+		int ret_inner;
+		const char* workdir;
+		const char* workdir_path;
+
+		ret = squash_stat(enclose_io_fs, path, &buf);
+		workdir = enclose_io_mkdir_workdir();
+		if (NULL == workdir) {
+			errno = ENOENT;
+			return -1;
+		}
+		workdir_path = malloc(strlen(workdir) + strlen(path) + 1);
+		if (NULL == workdir_path) {
+			errno = ENOMEM;
+			return -1;
+		}
+		strcpy(workdir_path, workdir);
+		strcat(workdir_path, path);
+		ret_inner = enclose_io_mkdir_consult(workdir_path, mode);
+		free(workdir_path);
+		if (0 == ret) {
+			errno = EEXIST;
+			return -1;
+		} else {
+			return ret_inner;
+		}
+	} else {
+		return mkdir(path, mode);
+	}
+}
+
+#ifdef _WIN32
+int enclose_io__wmkdir(wchar_t* pathname)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(pathname)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		return enclose_io_dos_return(enclose_io_mkdir(enclose_io_expanded, 0777));
+	} else if (enclose_io_is_path_w(pathname)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		return enclose_io_dos_return(enclose_io_mkdir(enclose_io_converted, 0777));
+	} else {
+		return _wmkdir(pathname);
+	}
+}
+#else
+int enclose_io__exec(const char *path, char *const argv[])
+{
+	int i, ret, argc;
+	char **new_argv, **argv_memory = NULL;
+	size_t exec_path_len = 2 * PATH_MAX;
+	char* exec_path = (char*)(malloc(exec_path_len));
+
+	ret = enclose_io_exepath(exec_path, &exec_path_len);
+	assert(0 == ret);
+
+	ret = setenv("ENCLOSE_IO_USE_ORIGINAL_RUBY", "true", 1);
+	ret = setenv("ENCLOSE_IO_USE_ORIGINAL_NODE", "true", 1);
+	assert(0 == ret);
+
+	argc = 1;
+	while (argv[argc]) { ++argc; }
+	new_argv = (char **)malloc( (2 + argc) * sizeof(char *));
+	assert(new_argv);
+	new_argv[0] = argv[0];
+	new_argv[1] = path;
+	for (i = 1; i < argc; ++i) {
+		new_argv[2 + i - 1] = argv[i];
+	}
+	new_argv[2 + argc - 1] = NULL;
+
+	ret = execv(exec_path, new_argv);
+
+	free(exec_path);
+	free(new_argv);
+	return ret;
+}
+
+int enclose_io_execv(const char *path, char *const argv[])
+{
+	const char* squash_extracted_path = NULL;
+
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		return enclose_io__exec(enclose_io_expanded, argv);
+	} else if (enclose_io_is_path(path)) {
+		return enclose_io__exec(path, argv);
+	} else {
+		return execv(path, argv);
+	}
+}
+
+int enclose_io_lstat(const char *path, struct stat *buf)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_lstat(enclose_io_fs, enclose_io_expanded, buf),
+			lstat(mkdir_workdir_expanded, buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_lstat(enclose_io_fs, path, buf),
+			lstat(mkdir_workdir_expanded, buf)
+		);
+	} else {
+		return lstat(path, buf);
+	}
+}
+
+ssize_t enclose_io_readlink(const char *path, char *buf, size_t bufsize)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_readlink(enclose_io_fs, enclose_io_expanded, buf, bufsize),
+			readlink(mkdir_workdir_expanded, buf, bufsize)
+		);
+	}
+	else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_readlink(enclose_io_fs, path, buf, bufsize),
+			readlink(mkdir_workdir_expanded, buf, bufsize)
+		);
+	}
+	else {
+		return readlink(path, buf, bufsize);
+	}
+}
+
+DIR * enclose_io_opendir(const char *filename)
+{
+	if (enclose_io_cwd[0] && '/' != *filename) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(filename);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			(DIR *)squash_opendir(enclose_io_fs, enclose_io_expanded),
+			opendir(mkdir_workdir_expanded)
+		);
+	}
+	else if (enclose_io_is_path(filename)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			filename,
+			(DIR *)squash_opendir(enclose_io_fs, filename),
+			opendir(mkdir_workdir_expanded)
+		);
+	}
+	else {
+		return opendir(filename);
+	}
+}
+
+DIR * enclose_io_fdopendir(int fd)
+{
+	sqfs_err error;
+	short found;
+	SQUASH_DIR *dir;
+	int *handle;
+	struct squash_file *file;
+	sqfs *fs;
+
+	if (!SQUASH_VALID_VFD(fd))
+	{
+		return fdopendir(fd);
+	}
+
+	file = squash_global_fdtable.fds[fd];
+
+	dir = calloc(1, sizeof(SQUASH_DIR));
+
+	if (NULL == dir)
+	{
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	fs = file->fs;
+
+	dir->fs = fs;
+	dir->entries = NULL;
+	dir->nr = 0;
+	dir->filename = strdup(file->filename);
+	dir->fd = fd;
+	dir->actual_nr = 0;
+	dir->loc = 0;
+
+	error = sqfs_inode_get(fs, &dir->node, sqfs_inode_root(fs));
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	error = sqfs_lookup_path_inner(fs, &dir->node, dir->filename, &found, 1);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	if (!found)
+	{
+		errno = ENOENT;
+		goto failure;
+	}
+	error = sqfs_dir_open(fs, &dir->node, &dir->dir, 0);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	
+	handle = (int *)(squash_global_fdtable.fds[dir->fd]->payload);
+
+	MUTEX_LOCK(&squash_global_mutex);
+	free(handle);
+	squash_global_fdtable.fds[dir->fd]->payload = (void *)dir;
+	MUTEX_UNLOCK(&squash_global_mutex);
+
+	return dir;
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	free(dir);
+	return NULL;
+}
+
+int enclose_io_closedir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_closedir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return closedir(dirp);
+	}
+}
+
+struct SQUASH_DIRENT * enclose_io_readdir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_readdir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return readdir(dirp);
+	}
+}
+
+long enclose_io_telldir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_telldir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return telldir(dirp);
+	}
+}
+
+void enclose_io_seekdir(DIR *dirp, long loc)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_seekdir((SQUASH_DIR *)dirp, loc);
+	}
+	else {
+		return seekdir(dirp, loc);
+	}
+}
+
+void enclose_io_rewinddir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_rewinddir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return rewinddir(dirp);
+	}
+}
+
+int enclose_io_dirfd(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_dirfd((SQUASH_DIR *)dirp);
+	}
+	else {
+		return dirfd(dirp);
+	}
+}
+
+int enclose_io_scandir(const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int(*select)(const struct SQUASH_DIRENT *),
+	int(*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **))
+{
+	if (enclose_io_cwd[0] && '/' != *dirname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(dirname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_scandir(enclose_io_fs, enclose_io_expanded, namelist, select, compar),
+			scandir(mkdir_workdir_expanded, namelist, select, compar)
+		);
+	}
+	else if (enclose_io_is_path(dirname)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			dirname,
+			squash_scandir(enclose_io_fs, dirname, namelist, select, compar),
+			scandir(mkdir_workdir_expanded, namelist, select, compar)
+		);
+	}
+	else {
+		return scandir(dirname, namelist, select, compar);
+	}
+}
+
+ssize_t enclose_io_pread(int d, void *buf, size_t nbyte, off_t offset)
+{
+	if (SQUASH_VALID_VFD(d)) {
+		off_t lseek_off, backup_off;
+		ssize_t read_ssize;
+		backup_off = squash_lseek(d, 0, SQUASH_SEEK_CUR);
+		if (-1 == backup_off) {
+			return -1;
+		}
+		lseek_off = squash_lseek(d, offset, SQUASH_SEEK_SET);
+		if (-1 == lseek_off) {
+			return -1;
+		}
+		read_ssize = squash_read(d, buf, nbyte);
+		if (-1 == read_ssize) {
+			return -1;
+		}
+		lseek_off = squash_lseek(d, backup_off, SQUASH_SEEK_SET);
+		assert(backup_off == lseek_off);
+		return read_ssize;
+	} else {
+		return pread(d, buf, nbyte, offset);
+	}
+}
+
+ssize_t enclose_io_readv(int d, const struct iovec *iov, int iovcnt)
+{
+	if (SQUASH_VALID_VFD(d)) {
+		int i;
+		ssize_t i_ssize;
+		ssize_t ret = 0;
+		for (i = 0; i < iovcnt; ++i) {
+			i_ssize = squash_read(d, iov[i].iov_base, iov[i].iov_len);
+			if (-1 == i_ssize) {
+				return -1;
+			} else if (0 == i_ssize) {
+				break;
+			} else {
+				ret += i_ssize;
+			}
+		}
+		return ret;
+	} else {
+		return readv(d, iov, iovcnt);
+	}
+}
+
+void* enclose_io_dlopen(const char* path, int mode)
+{
+    return dlopen(enclose_io_ifextract(path, NULL), mode);
+}
+
+int enclose_io_access(const char *path, int mode)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		struct stat buf;
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_stat(enclose_io_fs, enclose_io_expanded, &buf),
+			access(mkdir_workdir_expanded, &buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		struct stat buf;
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_stat(enclose_io_fs, path, &buf),
+			access(mkdir_workdir_expanded, &buf)
+		);
+	} else {
+		return access(path, mode);
+	}
+}
+
+#endif // !_WIN32
+
+int enclose_io_dos_return(int statement) {
+#ifdef _WIN32
+	int ret = (statement);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return ret;
+	} else {
+		return ret;
+	}
+#else
+	return (statement);
+#endif // _WIN32
+}
+
+short enclose_io_if(const char* path)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		return 1;
+	} else if (enclose_io_is_path(path)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+SQUASH_OS_PATH enclose_io_ifextract(const char* path, const char* ext_name)
+{
+    if (enclose_io_cwd[0] && '/' != *path) {
+        sqfs_path enclose_io_expanded;
+        size_t enclose_io_cwd_len;
+        size_t memcpy_len;
+        ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+        return squash_extract(enclose_io_fs, enclose_io_expanded, ext_name);
+    }
+    else if (enclose_io_is_path(path)) {
+        return squash_extract(enclose_io_fs, path, ext_name);
+    }
+    else {
+        return path;
+    }
+}
+
+void enclose_io_chdir_helper(const char *path)
+{
+        size_t memcpy_len = strlen(path);
+        if (SQUASHFS_PATH_LEN - 1 < memcpy_len) {
+        	memcpy_len = SQUASHFS_PATH_LEN - 1;
+        }
+        memcpy(enclose_io_cwd, path, memcpy_len);
+        while ('/' == enclose_io_cwd[memcpy_len - 1]) {
+        	memcpy_len--;
+        }
+        enclose_io_cwd[memcpy_len] = '/';
+        enclose_io_cwd[memcpy_len + 1] = '\0';
+}
+
+int enclose_io_chdir(const char *path)
+{
+	if (enclose_io_is_path(path)) {
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(path);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (path), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					int ret = chdir(mkdir_workdir_expanded);
+					if (0 == ret) {
+						enclose_io_chdir_helper(path);
+					}
+					return ret;
+				}
+			}
+		}
+
+		struct stat st;
+		int ret;
+
+		ret = squash_stat(enclose_io_fs, path, &st);
+		if (-1 == ret) {
+			#ifdef _WIN32
+			ENCLOSE_IO_SET_LAST_ERROR;
+			#endif
+			return -1;
+		}
+		if (S_ISDIR(st.st_mode)) {
+			enclose_io_chdir_helper(path);
+			return 0;
+		} else {
+			errno = ENOENT;
+			#ifdef _WIN32
+			ENCLOSE_IO_SET_LAST_ERROR;
+			#endif
+			return -1;
+		}
+	} else {
+		int ret;
+
+		ret = chdir(path);
+		if (0 == ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+char *enclose_io_getcwd(char *buf, size_t size)
+{
+	if (enclose_io_cwd[0]) {
+		size_t memcpy_len = strlen(enclose_io_cwd);
+		if (NULL == buf) {
+			buf = malloc((memcpy_len + 1) * sizeof(char));
+			if (NULL == buf) {
+				errno = ENOMEM;
+				#ifdef _WIN32
+				ENCLOSE_IO_SET_LAST_ERROR;
+				#endif
+				return NULL;
+			}
+		} else {
+			if (size - 1 < memcpy_len) {
+				memcpy_len = size - 1;
+			}
+		}
+		memcpy(buf, enclose_io_cwd, memcpy_len);
+		assert(memcpy_len - 1 >= 0);
+		buf[memcpy_len - 1] = '\0';
+		return buf;
+	} else {
+		return getcwd(buf, size);
+	}
+}
+
+char *enclose_io_getwd(char *buf)
+{
+	return enclose_io_getcwd(buf, MAXPATHLEN);
+}
+
+#ifdef _WIN32
+short enclose_io_if_w(const wchar_t* path)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(path)) {
+		return 1;
+	} else if (enclose_io_is_path_w(path)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+BOOL
+EncloseIOSetCurrentDirectoryW(
+	LPCWSTR lpPathName
+)
+{
+	if (enclose_io_is_path_w(lpPathName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+		int ret;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpPathName);
+
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(enclose_io_converted);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (enclose_io_converted), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					BOOL ret = SetCurrentDirectory(mkdir_workdir_expanded);
+					if (ret) {
+						enclose_io_chdir_helper(enclose_io_converted);
+					}
+					return ret;
+				}
+			}
+		}
+
+		ret = enclose_io_chdir(enclose_io_converted);
+		if (0 == ret) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		BOOL ret = SetCurrentDirectoryW(lpPathName);
+		// If the function succeeds, the return value is nonzero.
+		if (ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+DWORD
+EncloseIOGetCurrentDirectoryW(
+	DWORD nBufferLength,
+	LPWSTR lpBuffer
+)
+{
+	if (enclose_io_cwd[0]) {
+		size_t x;
+		char *ret = enclose_io_getcwd(NULL, 0);
+		if (NULL == ret) {
+			return 0;
+		}
+		x = mbstowcs(lpBuffer, ret, nBufferLength - 1);
+		free(ret);
+		if (NULL == lpBuffer) {
+			return x + 1;
+		} else {
+			return x;
+		}
+	} else {
+		return GetCurrentDirectoryW(
+			nBufferLength,
+			lpBuffer
+		);
+	}
+}
+
+DWORD
+EncloseIOGetFullPathNameW(
+	LPCWSTR lpFileName,
+	DWORD nBufferLength,
+	LPWSTR lpBuffer,
+	LPWSTR* lpFilePart
+)
+{
+	DWORD retval = 0;
+
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		wchar_t enclose_io_expanded_w[SQUASHFS_PATH_LEN + 1];
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+
+		mbstowcs(enclose_io_expanded_w, enclose_io_expanded, SQUASHFS_PATH_LEN);
+		enclose_io_expanded_w[SQUASHFS_PATH_LEN] = 0;
+
+		retval = GetFullPathNameW(
+			enclose_io_expanded_w,
+			nBufferLength,
+			lpBuffer,
+			lpFilePart
+		);
+	} else {
+		retval = GetFullPathNameW(
+			lpFileName,
+			nBufferLength,
+			lpBuffer,
+			lpFilePart
+		);
+	}
+
+	if (0 == retval || retval > nBufferLength) {
+		return retval;
+	}
+
+	if (0 == wcsncmp(lpBuffer + 1, L":\\__enclose_io_memfs__", 22)) {
+		assert(NULL == lpFilePart); // TODO
+		memmove(lpBuffer, lpBuffer + 2, (retval - 2) * sizeof(wchar_t));
+		return retval - 2;
+	}
+	
+	return retval;
+}
+
+#endif // _WIN32
+
+int enclose_io_stat(const char *path, struct stat *buf)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_stat(enclose_io_fs, enclose_io_expanded, buf)),
+			stat(mkdir_workdir_expanded, buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			enclose_io_dos_return(squash_stat(enclose_io_fs, path, buf)),
+			stat(mkdir_workdir_expanded, buf)
+		);
+	} else {
+		return stat(path, buf);
+	}
+}
+
+int enclose_io_fstat(int fildes, struct stat *buf)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_fstat(fildes, buf));
+	} else {
+		return fstat(fildes, buf);
+	}
+}
+
+int enclose_io_open(int nargs, const char *pathname, int flags, ...)
+{
+	if (enclose_io_cwd[0] && '/' != *pathname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(pathname);
+		if (!(O_CREAT & flags)) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_expanded,
+				enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+				open(mkdir_workdir_expanded, flags)
+			);
+		} else {
+			va_list args;
+			mode_t mode;
+			assert(3 == nargs);
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			char *dir_thereof_ptr = strrchr(enclose_io_expanded, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_expanded, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_expanded);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_expanded, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return enclose_io_dos_return(open(mkdir_workdir_expanded, flags, mode));
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else if (enclose_io_is_path(pathname)) {
+		if (!(O_CREAT & flags)) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				pathname,
+				enclose_io_dos_return(squash_open(enclose_io_fs, pathname)),
+				open(mkdir_workdir_expanded, flags)
+			);
+		} else {
+			va_list args;
+			mode_t mode;
+			assert(3 == nargs);
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			char *dir_thereof_ptr = strrchr(pathname, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(pathname, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(pathname);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], pathname, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return enclose_io_dos_return(open(mkdir_workdir_expanded, flags, mode));
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else {
+		if (2 == nargs) {
+			return open(pathname, flags);
+		} else {
+			va_list args;
+			mode_t mode;
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			return open(pathname, flags, mode);
+		}
+	}
+}
+
+int enclose_io_close(int fildes)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_close(fildes));
+	} else {
+		return close(fildes);
+	}
+}
+
+ssize_t enclose_io_read(int fildes, void *buf, size_t nbyte)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_read(fildes, buf, nbyte));
+	} else {
+		return read(fildes, buf, nbyte);
+	}
+}
+
+off_t enclose_io_lseek(int fildes, off_t offset, int whence)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_lseek(fildes, offset, whence));
+	} else {
+		return lseek(fildes, offset, whence);
+	}
+}
+
+short enclose_io_is_path(char *pathname)
+{
+	if (strnlen((pathname), 21) >= 21) {
+		if (0 == strncmp((pathname), "/__enclose_io_memfs__", 21)
+#ifdef _WIN32
+			|| 0 == strncmp((pathname), "\\__enclose_io_memfs__", 21)
+#endif
+			) {
+				return 1;
+			}
+	}
+#ifdef _WIN32
+	if (strnlen((pathname), 23) >= 23) {
+		if (0 == strncmp((pathname) + 1, ":/__enclose_io_memfs__", 22)
+			|| 0 == strncmp((pathname) + 1, ":\\__enclose_io_memfs__", 22)
+			) {
+				return 1;
+			}
+	}
+	if (strnlen((pathname), 24) >= 24) {
+		if (0 == strncmp((pathname), "\\\\?\\__enclose_io_memfs__", 24) ||
+			0 == strncmp((pathname), "//?/__enclose_io_memfs__", 24)) {
+				return 1;
+			}
+	}
+	if (strnlen((pathname), 27) >= 27) {
+		if (0 == strncmp((pathname), "\\\\?\\", 4) ||
+			0 == strncmp((pathname), "//?/", 4)) {
+			if (0 == strncmp((pathname) + 5, ":\\__enclose_io_memfs__", 22) ||
+				0 == strncmp((pathname) + 5, ":/__enclose_io_memfs__", 22)) {
+					return 1;
+				}
+		}
+	}
+#endif
+	return 0;
+}
+
+#ifdef _WIN32
+short enclose_io_is_path_w(wchar_t *pathname)
+{
+	if (wcsnlen((pathname), 21) >= 21) {
+		if (0 == wcsncmp((pathname), L"/__enclose_io_memfs__", 21)
+			|| 0 == wcsncmp((pathname), L"\\__enclose_io_memfs__", 21)
+			) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 23) >= 23) {
+		if (0 == wcsncmp((pathname) + 1, L":/__enclose_io_memfs__", 22)
+			|| 0 == wcsncmp((pathname) + 1, L":\\__enclose_io_memfs__", 22)
+			) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 24) >= 24) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\__enclose_io_memfs__", 24) ||
+			0 == wcsncmp((pathname), L"//?/__enclose_io_memfs__", 24)) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 27) >= 27) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) ||
+			0 == wcsncmp((pathname), L"//?/", 4)) {
+			if (0 == wcsncmp((pathname) + 5, L":\\__enclose_io_memfs__", 22) ||
+				0 == wcsncmp((pathname) + 5, L":/__enclose_io_memfs__", 22)) {
+					return 1;
+				}
+		}
+	}
+	return 0;
+}
+
+short enclose_io_is_relative_w(wchar_t *pathname)
+{
+	if (L'N' == pathname[0] && L'U' == pathname[1] && L'L' == pathname[2] && 0 == pathname[3]) {
+		return 0;
+	}
+	if (L'\\' == (pathname)[0] ||
+		L'/' == (pathname)[0]) {
+		return 0;
+	}
+	if (wcsnlen(pathname, 3) >= 3) {
+		if (0 == wcsncmp((pathname) + 1, L":\\", 2) ||
+			0 == wcsncmp((pathname) + 1, L":/", 2)) {
+			return 0;
+		}
+	}
+	if (wcsnlen(pathname, 4) >= 4) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) ||
+			0 == wcsncmp((pathname), L"//?/", 4)) {
+			return 0;
+		}
+	}
+	if (wcsnlen(pathname, 7) >= 7) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) && 0 == wcsncmp((pathname) + 5, L":\\", 2) ) {
+				return 0;
+			}
+		if (0 == wcsncmp((pathname), L"//?/", 4) && 0 == wcsncmp((pathname) + 5, L":/", 2) ) {
+				return 0;
+			}
+	}
+	return 1;
+}
+#endif
+
+#ifndef _WIN32
+int enclose_io_openat(int nargs, int dirfd, const char* pathname, int flags, ...)
+{
+    if (3 == nargs) {
+        // If pathname is absolute, then dirfd is ignored.
+        if (enclose_io_is_path(pathname)) {
+            return enclose_io_open(nargs, pathname, flags);
+        }
+
+        // If the pathname given in pathname is relative,
+        // then it is interpreted relative to the directory referred to by the file descriptor dirfd
+        // (rather than relative to the current working directory of the calling process, as is done by open(2) for a relative pathname).
+        // TODO: at dirfd
+        if (dirfd == AT_FDCWD && enclose_io_cwd[0] && '/' != *pathname) {
+            return enclose_io_open(nargs, pathname, flags);
+        }
+
+        return openat(dirfd, pathname, flags);
+    }
+    else {
+        va_list args;
+        mode_t mode;
+        assert(4 == nargs);
+        va_start(args, flags);
+        mode = va_arg(args, mode_t);
+        va_end(args);
+
+        // If pathname is absolute, then dirfd is ignored.
+        if (enclose_io_is_path(pathname)) {
+            return enclose_io_open(nargs, pathname, flags, mode);
+        }
+
+        // If the pathname given in pathname is relative,
+        // then it is interpreted relative to the directory referred to by the file descriptor dirfd
+        // (rather than relative to the current working directory of the calling process, as is done by open(2) for a relative pathname).
+        // TODO: at dirfd
+        if (dirfd == AT_FDCWD && enclose_io_cwd[0] && '/' != *pathname) {
+            return enclose_io_open(nargs, pathname, flags, mode);
+        }
+
+        return openat(dirfd, pathname, flags, mode);
+    }
+}
+#endif
+
+/*
+ * enclose_io_exepath is derived from uv_exepath of libuv.
+ * libuv is licensed for use as follows:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#ifdef _WIN32
+int enclose_io_exepath(char* buffer, size_t* size_ptr) {
+  int utf8_len, utf16_buffer_len, utf16_len;
+  WCHAR* utf16_buffer;
+  int err;
+
+  if (buffer == NULL || size_ptr == NULL || *size_ptr == 0) {
+    return -1;
+  }
+
+  if (*size_ptr > 32768) {
+    /* Windows paths can never be longer than this. */
+    utf16_buffer_len = 32768;
+  } else {
+    utf16_buffer_len = (int) *size_ptr;
+  }
+
+  utf16_buffer = (WCHAR*) malloc(sizeof(WCHAR) * utf16_buffer_len);
+  if (!utf16_buffer) {
+    return -1;
+  }
+
+  /* Get the path as UTF-16. */
+  utf16_len = GetModuleFileNameW(NULL, utf16_buffer, utf16_buffer_len);
+  if (utf16_len <= 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  /* utf16_len contains the length, *not* including the terminating null. */
+  utf16_buffer[utf16_len] = L'\0';
+
+  /* Convert to UTF-8 */
+  utf8_len = WideCharToMultiByte(CP_UTF8,
+                                 0,
+                                 utf16_buffer,
+                                 -1,
+                                 buffer,
+                                 (int) *size_ptr,
+                                 NULL,
+                                 NULL);
+  if (utf8_len == 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  free(utf16_buffer);
+
+  /* utf8_len *does* include the terminating null at this point, but the */
+  /* returned size shouldn't. */
+  *size_ptr = utf8_len - 1;
+  return 0;
+
+ error:
+  free(utf16_buffer);
+  return -1;
+}
+
+#endif
+
+#ifdef __linux__
+int enclose_io_exepath(char* buffer, size_t* size) {
+  ssize_t n;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  n = *size - 1;
+  if (n > 0)
+    n = readlink("/proc/self/exe", buffer, n);
+
+  if (n == -1)
+    return -1;
+
+  buffer[n] = '\0';
+  *size = n;
+
+  return 0;
+}
+#endif
+
+#ifdef __APPLE__
+int enclose_io_exepath(char* buffer, size_t* size) {
+  /* realpath(exepath) may be > PATH_MAX so double it to be on the safe side. */
+  char abspath[PATH_MAX * 2 + 1];
+  char exepath[PATH_MAX + 1];
+  uint32_t exepath_size;
+  size_t abspath_size;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  exepath_size = sizeof(exepath);
+  if (_NSGetExecutablePath(exepath, &exepath_size))
+    return -1;
+
+  if (realpath(exepath, abspath) != abspath)
+    return -1;
+
+  abspath_size = strlen(abspath);
+  if (abspath_size == 0)
+    return -1;
+
+  *size -= 1;
+  if (*size > abspath_size)
+    *size = abspath_size;
+
+  memcpy(buffer, abspath, *size);
+  buffer[*size] = '\0';
+
+  return 0;
+}
+#endif
diff --git a/ruby/enclose_io_unix.h b/ruby/enclose_io_unix.h
new file mode 100644
index 00000000..291f5277
--- /dev/null
+++ b/ruby/enclose_io_unix.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2017 - 2020 Minqi Pan <pmq2001@gmail.com>
+ *                           Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_UNIX_H_E0229A03
+#define ENCLOSE_IO_UNIX_H_E0229A03
+#ifndef __cplusplus
+#ifndef _WIN32
+
+	#ifdef dirfd
+		#undef dirfd
+	#endif
+
+	#define getcwd(...)	enclose_io_getcwd(__VA_ARGS__)
+	#define getwd(...)	enclose_io_getwd(__VA_ARGS__)
+	#define chdir(...)	enclose_io_chdir(__VA_ARGS__)
+	#define stat(...)	enclose_io_stat(__VA_ARGS__)
+	#define fstat(...)	enclose_io_fstat(__VA_ARGS__)
+	#define lstat(...)	enclose_io_lstat(__VA_ARGS__)
+	#define open(...)	enclose_io_open(ENCLOSE_IO_PP_NARG(__VA_ARGS__), __VA_ARGS__)
+	#define openat(...)	enclose_io_openat(ENCLOSE_IO_PP_NARG(__VA_ARGS__), __VA_ARGS__)
+	#define close(...)	enclose_io_close(__VA_ARGS__)
+	#define read(...)	enclose_io_read(__VA_ARGS__)
+	#define lseek(...)	enclose_io_lseek(__VA_ARGS__)
+	#define readlink(...)	enclose_io_readlink(__VA_ARGS__)
+	#define opendir(...)	enclose_io_opendir(__VA_ARGS__)
+	#define fdopendir(...)	enclose_io_fdopendir(__VA_ARGS__)
+	#define closedir(...)	enclose_io_closedir(__VA_ARGS__)
+	#define readdir(...)	enclose_io_readdir(__VA_ARGS__)
+	#define telldir(...)	enclose_io_telldir(__VA_ARGS__)
+	#define seekdir(...)	enclose_io_seekdir(__VA_ARGS__)
+	#define rewinddir(...)	enclose_io_rewinddir(__VA_ARGS__)
+	#define dirfd(...)	enclose_io_dirfd(__VA_ARGS__)
+	#define scandir(...)	enclose_io_scandir(__VA_ARGS__)
+	#define pread(...)	enclose_io_pread(__VA_ARGS__)
+	#define readv(...)	enclose_io_readv(__VA_ARGS__)
+	#define dlopen(...)	enclose_io_dlopen(__VA_ARGS__)
+	#define access(...)	enclose_io_access(__VA_ARGS__)
+	#define mkdir(...)	enclose_io_mkdir(__VA_ARGS__)
+	#define execv(...)	enclose_io_execv(__VA_ARGS__)
+
+#endif // !_WIN32
+#endif //!__cplusplus
+#endif
diff --git a/ruby/enclose_io_win32.c b/ruby/enclose_io_win32.c
new file mode 100644
index 00000000..85528ddd
--- /dev/null
+++ b/ruby/enclose_io_win32.c
@@ -0,0 +1,1325 @@
+/*
+ * Copyright (c) 2017 - 2020 Minqi Pan <pmq2001@gmail.com>
+ *                           Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "enclose_io_common.h"
+
+#ifdef _WIN32
+
+extern char *mkdir_workdir;
+extern char *enclose_io_mkdir_scope;
+
+int enclose_io__open(const char *pathname, int flags)
+{
+	if (enclose_io_cwd[0] && '/' != *pathname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(pathname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+			_open(mkdir_workdir_expanded, flags)
+		);
+	} else if (enclose_io_is_path(pathname)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			pathname,
+			enclose_io_dos_return(squash_open(enclose_io_fs, pathname)),
+			_open(mkdir_workdir_expanded, flags)
+		);
+	} else {
+                return _open(pathname, flags);
+	}
+}
+
+int enclose_io__wopen(const wchar_t *pathname, int flags, int mode)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(pathname)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+			_open(mkdir_workdir_expanded, flags, mode)
+		);
+	} else if (enclose_io_is_path_w(pathname)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_converted)),
+			_open(mkdir_workdir_expanded, flags, mode)
+		);
+	} else {
+		return _wopen(pathname, flags, mode);
+	}
+}
+
+int enclose_io_open_osfhandle(intptr_t osfhandle, int flags)
+{
+	struct squash_file *entry = squash_find_entry((void *)osfhandle);
+	if (entry) {
+		return entry->fd;
+	} else {
+		return _open_osfhandle(osfhandle, flags);
+	}
+}
+
+intptr_t enclose_io_get_osfhandle(int fd)
+{
+	if (SQUASH_VALID_VFD(fd)) {
+		assert(!(S_ISDIR(squash_global_fdtable.fds[fd]->st.st_mode)));
+		return (intptr_t)(squash_global_fdtable.fds[fd]->payload);
+	}
+	else {
+		return _get_osfhandle(fd);
+	}
+}
+
+int enclose_io_wchdir(const wchar_t *path)
+{
+	if (enclose_io_is_path_w(path)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+		struct stat st;
+		int ret;
+
+		W_ENCLOSE_IO_PATH_CONVERT(path);
+
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(enclose_io_converted);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (enclose_io_converted), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					int ret = _chdir(mkdir_workdir_expanded);
+					if (0 == ret) {
+						enclose_io_chdir_helper(enclose_io_converted);
+					}
+					return ret;
+				}
+			}
+		}
+
+		ret = squash_stat(enclose_io_fs, enclose_io_converted, &st);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+		if (S_ISDIR(st.st_mode)) {
+			enclose_io_chdir_helper(enclose_io_converted);
+			return 0;
+		} else {
+			errno = ENOENT;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+	} else {
+		int ret = _wchdir(path);
+		if (0 == ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+wchar_t *enclose_io_wgetcwd(wchar_t *buf, size_t size)
+{
+        wchar_t tempbuf[SQUASHFS_PATH_LEN + 1];
+        size_t retlen;
+	if (enclose_io_cwd[0]) {
+		retlen = mbstowcs(tempbuf, enclose_io_cwd, SQUASHFS_PATH_LEN);
+		if ((size_t)-1 == retlen) {
+                        errno = ERANGE;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+			return NULL;
+		}
+                tempbuf[retlen] = L'\0';
+		if (NULL == buf) {
+			buf = malloc((retlen + 1) * sizeof(wchar_t));
+			if (NULL == buf) {
+				errno = ENOMEM;
+				return NULL;
+			}
+		} else {
+			if (size - 1 < retlen) {
+				retlen = size - 1;
+			}
+		}
+		memcpy(buf, tempbuf, retlen * sizeof(wchar_t));
+		buf[retlen] = L'\0';
+		return buf;
+	} else {
+		return _wgetcwd(buf, size);
+	}
+}
+
+int enclose_io_fstati64(int fildes, struct _stati64 *buf)
+{
+        struct stat st;
+	if (SQUASH_VALID_VFD(fildes)) {
+		if (NULL == buf) {
+                        errno = EINVAL;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+		st = SQUASH_VFD_FILE(fildes)->st;
+		buf->st_dev = st.st_dev;
+		buf->st_ino = st.st_ino;
+		buf->st_mode = st.st_mode;
+		buf->st_nlink = st.st_nlink;
+		buf->st_uid = st.st_uid;
+		buf->st_gid = st.st_gid;
+		buf->st_rdev = st.st_rdev;
+		buf->st_size = st.st_size;
+		buf->st_atime = st.st_atime;
+		buf->st_mtime = st.st_mtime;
+		buf->st_ctime = st.st_ctime;
+		return 0;
+	} else {
+		return _fstati64(fildes, buf);
+	}
+}
+
+__int64 enclose_io_lseeki64(int fildes, __int64 offset, int whence)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_lseek(fildes, offset, whence));
+	} else {
+		return _lseeki64(fildes, offset, whence);
+	}
+}
+
+static HANDLE EncloseIOCreateFileWHelper(
+	char * incoming,
+	DWORD dwFlagsAndAttributes)
+{
+	int ret;
+	struct stat buf;
+	SQUASH_DIR *dirp;
+	int follow_link;
+
+	if (dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT) {
+		ret = squash_lstat(enclose_io_fs, incoming, &buf);
+		follow_link = 0;
+	} else {
+		ret = squash_stat(enclose_io_fs, incoming, &buf);
+		follow_link = 1;
+	}
+
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return INVALID_HANDLE_VALUE;
+	}
+	if (S_ISDIR(buf.st_mode)) {
+		dirp = squash_opendir_inner(enclose_io_fs, incoming, follow_link);
+		if (NULL != dirp) {
+			return (HANDLE)(dirp);
+		} else {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return INVALID_HANDLE_VALUE;
+		}
+	} else {
+		ret = squash_open_inner(enclose_io_fs, incoming, follow_link);
+		if (ret >= 0) {
+			return (HANDLE)(squash_global_fdtable.fds[ret]->payload);
+		} else {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return INVALID_HANDLE_VALUE;
+		}
+	}
+}
+
+HANDLE
+EncloseIOCreateFileW(
+	LPCWSTR lpFileName,
+	DWORD dwDesiredAccess,
+	DWORD dwShareMode,
+	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+	DWORD dwCreationDisposition,
+	DWORD dwFlagsAndAttributes,
+	HANDLE hTemplateFile
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		if (OPEN_EXISTING == dwCreationDisposition) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_expanded,
+				EncloseIOCreateFileWHelper(
+					enclose_io_expanded,
+					dwFlagsAndAttributes
+				),
+				CreateFile(
+					mkdir_workdir_expanded,
+					dwDesiredAccess,
+					dwShareMode,
+					lpSecurityAttributes,
+					dwCreationDisposition,
+					dwFlagsAndAttributes,
+					hTemplateFile
+				)
+			);
+		} else {
+			char *dir_thereof_ptr = strrchr(enclose_io_expanded, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_expanded, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_expanded);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_expanded, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return CreateFile(
+						mkdir_workdir_expanded,
+						dwDesiredAccess,
+						dwShareMode,
+						lpSecurityAttributes,
+						dwCreationDisposition,
+						dwFlagsAndAttributes,
+						hTemplateFile
+					);
+				} else {
+					errno = ENOENT;
+                                        ENCLOSE_IO_SET_LAST_ERROR;
+                                        return INVALID_HANDLE_VALUE;
+				}
+			} else {
+				errno = ENOENT;
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return INVALID_HANDLE_VALUE;
+			}
+		}
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		if (OPEN_EXISTING == dwCreationDisposition) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_converted,
+				EncloseIOCreateFileWHelper(
+					enclose_io_converted,
+					dwFlagsAndAttributes
+				),
+				CreateFile(
+					mkdir_workdir_expanded,
+					dwDesiredAccess,
+					dwShareMode,
+					lpSecurityAttributes,
+					dwCreationDisposition,
+					dwFlagsAndAttributes,
+					hTemplateFile
+				)
+			);
+		} else {
+			char *dir_thereof_ptr = strrchr(enclose_io_converted, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_converted, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_converted);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_converted, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return CreateFile(
+						mkdir_workdir_expanded,
+						dwDesiredAccess,
+						dwShareMode,
+						lpSecurityAttributes,
+						dwCreationDisposition,
+						dwFlagsAndAttributes,
+						hTemplateFile
+					);
+				} else {
+					errno = ENOENT;
+                                        ENCLOSE_IO_SET_LAST_ERROR;
+                                        return INVALID_HANDLE_VALUE;
+				}
+			} else {
+				errno = ENOENT;
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return INVALID_HANDLE_VALUE;
+			}
+		}
+	} else {
+		return CreateFileW(
+			lpFileName,
+			dwDesiredAccess,
+			dwShareMode,
+			lpSecurityAttributes,
+			dwCreationDisposition,
+			dwFlagsAndAttributes,
+			hTemplateFile
+		);
+	}
+}
+
+BOOL
+EncloseIOCloseHandle(
+	HANDLE hObject
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hObject);
+	if (sqf) {
+                int ret;
+		if (S_ISDIR(sqf->st.st_mode)) {
+			ret = squash_closedir((SQUASH_DIR *)hObject);
+                        if (-1 == ret) {
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return FALSE;
+                        }
+			return TRUE;
+		} else {
+			ret = squash_close(*((int *)hObject));
+                        if (-1 == ret) {
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return FALSE;
+                        }
+			return TRUE;
+		}
+	} else {
+		return CloseHandle(
+			hObject
+		);
+	}
+}
+
+BOOL
+EncloseIOReadFile(
+	HANDLE       hFile,
+	LPVOID       lpBuffer,
+	DWORD        nNumberOfBytesToRead,
+	LPDWORD      lpNumberOfBytesRead,
+	LPOVERLAPPED lpOverlapped
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFile);
+        int ret;
+
+	if (sqf) {
+		if (NULL != lpOverlapped) {
+                        squash_lseek(sqf->fd, lpOverlapped->Offset, SQUASH_SEEK_SET);
+                        assert(0 == lpOverlapped->OffsetHigh); // TODO support OffsetHigh
+                }
+		ret = squash_read(sqf->fd, lpBuffer, nNumberOfBytesToRead);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		*lpNumberOfBytesRead = ret;
+		return TRUE;
+	} else {
+		return ReadFile(
+			hFile,
+			lpBuffer,
+			nNumberOfBytesToRead,
+			lpNumberOfBytesRead,
+			lpOverlapped
+		);
+	}
+}
+
+static DWORD EncloseIOGetFileAttributesHelper(struct stat *st)
+{
+	DWORD fa = 0; //FILE_ATTRIBUTE_READONLY;
+	if (S_ISCHR(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_DEVICE;
+	} else if (S_ISLNK(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_REPARSE_POINT;
+	} else if (S_ISDIR(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_DIRECTORY;
+	} else {
+		fa |= FILE_ATTRIBUTE_NORMAL;
+	}
+	return fa;
+}
+
+DWORD
+EncloseIOGetFileAttributesWHelper(
+	const char *path
+)
+{
+	int ret;
+	struct stat buf;
+	ret = squash_stat(enclose_io_fs, path, &buf);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return INVALID_FILE_ATTRIBUTES;
+	}
+	return EncloseIOGetFileAttributesHelper(&buf);
+}
+
+DWORD
+EncloseIOGetFileAttributesW(
+    LPCWSTR lpFileName
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOGetFileAttributesWHelper(enclose_io_expanded),
+			GetFileAttributes(
+				mkdir_workdir_expanded
+			)
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOGetFileAttributesWHelper(enclose_io_converted),
+			GetFileAttributes(
+				mkdir_workdir_expanded
+			)
+		);
+	} else {
+		return GetFileAttributesW(
+			lpFileName
+		);
+	}
+}
+
+static void EncloseIOUnixtimeToFiletime(time_t time, FILETIME *ft)
+{
+    ULARGE_INTEGER tmp;
+    tmp.QuadPart = ((long long)time + (long long)((1970-1601)*365.2425) * 24 * 60 * 60) * 10 * 1000 * 1000;
+    ft->dwLowDateTime = tmp.LowPart;
+    ft->dwHighDateTime = tmp.HighPart;
+}
+
+static void EncloseIOFillWin32FileAttributeDataHelper(WIN32_FILE_ATTRIBUTE_DATA *fa, struct stat *st)
+{
+        fa->dwFileAttributes = EncloseIOGetFileAttributesHelper(st);
+        EncloseIOUnixtimeToFiletime(st->st_atime, &fa->ftLastAccessTime);
+        EncloseIOUnixtimeToFiletime(st->st_mtime, &fa->ftLastWriteTime);
+        EncloseIOUnixtimeToFiletime(st->st_ctime, &fa->ftCreationTime);
+        // TODO somehow support large files?
+        fa->nFileSizeHigh = 0;
+        fa->nFileSizeLow = st->st_size;
+}
+
+BOOL
+EncloseIOGetFileAttributesExWHelper(
+	const char *path,
+	LPVOID lpFileInformation
+)
+{
+	int ret;
+	struct stat buf;
+	WIN32_FILE_ATTRIBUTE_DATA *fa;
+
+	ret = squash_stat(enclose_io_fs, path, &buf);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return 0;
+	}
+	fa = (WIN32_FILE_ATTRIBUTE_DATA *)lpFileInformation;
+	EncloseIOFillWin32FileAttributeDataHelper(fa, &buf);
+	return 1;
+}
+
+BOOL
+EncloseIOGetFileAttributesExW(
+    LPCWSTR lpFileName,
+    GET_FILEEX_INFO_LEVELS fInfoLevelId,
+    LPVOID lpFileInformation
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		assert(GetFileExInfoStandard == fInfoLevelId);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOGetFileAttributesExWHelper(enclose_io_expanded, lpFileInformation),
+			GetFileAttributesEx(
+				mkdir_workdir_expanded,
+				fInfoLevelId,
+				lpFileInformation
+			),
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		assert(GetFileExInfoStandard == fInfoLevelId);
+
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOGetFileAttributesExWHelper(enclose_io_converted, lpFileInformation),
+			GetFileAttributesEx(
+				mkdir_workdir_expanded,
+				fInfoLevelId,
+				lpFileInformation
+			)
+		);
+	} else {
+		return GetFileAttributesExW(
+			lpFileName,
+			fInfoLevelId,
+			lpFileInformation
+		);
+	}
+}
+
+BOOL
+EncloseIOGetHandleInformation(
+    HANDLE hObject,
+    LPDWORD lpdwFlags
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hObject);
+        if (sqf) {
+                *lpdwFlags = 0;
+                return 1;
+        } else {
+                return GetHandleInformation(
+                        hObject,
+                        lpdwFlags
+                );
+        }
+}
+
+DWORD
+EncloseIOGetFileType(
+        HANDLE hFile
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFile);
+        if (sqf) {
+                struct stat st;
+		st = sqf->st;
+                if (S_ISCHR(st.st_mode)) {
+                        return FILE_TYPE_CHAR;
+                } else if (S_ISREG(st.st_mode)) {
+                        return FILE_TYPE_DISK;
+                } else if (S_ISFIFO(st.st_mode)) {
+                        return FILE_TYPE_PIPE;
+                } else {
+                        return FILE_TYPE_UNKNOWN;
+                }
+        } else {
+                return GetFileType(
+                        hFile
+                );
+        }
+}
+
+DWORD EncloseIODType2FileAttributes(int d_type)
+{
+        DWORD x = 0; //FILE_ATTRIBUTE_READONLY;
+        if (DT_CHR == d_type) {
+                x |= FILE_ATTRIBUTE_DEVICE;
+        } else if (DT_LNK == d_type) {
+                x |= FILE_ATTRIBUTE_REPARSE_POINT;
+        } else if (DT_DIR == d_type) {
+                x |= FILE_ATTRIBUTE_DIRECTORY;
+        } else {
+                x |= FILE_ATTRIBUTE_NORMAL;
+        }
+        return x;
+}
+
+HANDLE
+EncloseIOFindFirstFileHelper(
+        char *incoming,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+        char *dup_incoming = strdup(incoming);
+        char *parent = incoming + strlen(incoming);
+        SQUASH_DIR *dirp;
+        struct SQUASH_DIRENT *mydirent;
+				struct SQUASH_DIRENT dummy_dirent;
+        char *current_path_tail;
+        char *current_path;
+        size_t mbstowcs_size;
+
+        while (parent >= incoming) {
+                if ('/' == *parent) {
+                        break;
+                }
+                parent -= 1;
+        }
+        *parent = '\0';
+        dirp = squash_opendir(enclose_io_fs, incoming);
+        if (NULL == dirp) {
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return INVALID_HANDLE_VALUE;
+        }
+        dirp->payload = dup_incoming;
+        current_path = (char *)malloc(strlen(dup_incoming) + SQUASHFS_PATH_LEN + 1);
+        if (NULL == current_path) {
+                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+                return INVALID_HANDLE_VALUE;
+        }
+        memcpy(current_path, incoming, strlen(incoming) + 1);
+        strcat(current_path, "/");
+        current_path_tail = current_path + strlen(current_path);
+        do {
+        	mydirent = squash_readdir(dirp);
+                if (NULL == mydirent) {
+									// try to determine
+									// either this dir is empty
+									// or the dir is not empty and we run out of possible matches
+									if (dirp->actual_nr == 0) {
+										// this dir is empty
+										// so just return a "." to match the original Windows behavior
+										current_path_tail[0] = '.';
+										current_path_tail[1] = 0; // we are sure that this will make true==PathMatchSpecA(current_path, dup_incoming)
+										dummy_dirent.d_namlen = 1;
+										dummy_dirent.d_ino = dirp->node.base.inode_number;
+										dummy_dirent.d_name[0] = '.';
+										dummy_dirent.d_name[1] = 0;
+										dummy_dirent.d_type = DT_DIR;
+										mydirent = &dummy_dirent;
+									}
+									break;
+                }
+                memcpy(current_path_tail, mydirent->d_name, strlen(mydirent->d_name) + 1);
+        } while (!PathMatchSpecA(current_path, dup_incoming));
+        free(current_path);
+        if (NULL == mydirent) {
+                int ret = squash_closedir(dirp);
+                assert(0 == ret);
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return INVALID_HANDLE_VALUE;
+        }
+        mbstowcs_size = mbstowcs(lpFindFileData->cFileName, mydirent->d_name, sizeof(lpFindFileData->cFileName) / sizeof(lpFindFileData->cFileName[0]) - 1);
+        if ((size_t)-1 == mbstowcs_size) {
+                errno = EIO;
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return 0;
+        }
+        lpFindFileData->cFileName[mbstowcs_size] = 0;
+        lpFindFileData->cAlternateFileName[0] = 0;
+        lpFindFileData->dwFileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+        return (HANDLE)(dirp);
+}
+
+HANDLE
+EncloseIOFindFirstFileW(
+        LPCWSTR lpFileName,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOFindFirstFileHelper(enclose_io_expanded, lpFindFileData),
+			FindFirstFile(
+				mkdir_workdir_expanded,
+				lpFindFileData
+			)
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOFindFirstFileHelper(enclose_io_converted, lpFindFileData),
+			FindFirstFile(
+				mkdir_workdir_expanded,
+				lpFindFileData
+			)
+		);
+	} else {
+		return FindFirstFileW(
+			lpFileName,
+			lpFindFileData
+		);
+	}
+}
+
+BOOL
+EncloseIOFindNextFileW(
+        HANDLE hFindFile,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFindFile);
+
+	if (sqf) {
+                SQUASH_DIR *dirp;
+                struct SQUASH_DIRENT *mydirent;
+                char *current_path;
+                char *current_path_tail;
+                size_t mbstowcs_size;
+
+                dirp = (SQUASH_DIR*)hFindFile;
+                current_path = (char *)malloc(strlen((char *)(dirp->payload)) + SQUASHFS_PATH_LEN + 1);
+                if (NULL == current_path) {
+                        errno = ENOMEM;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+                memcpy(current_path, dirp->filename, strlen(dirp->filename) + 1);
+                strcat(current_path, "/");
+                current_path_tail = current_path + strlen(current_path);
+                do {
+                        mydirent = squash_readdir(dirp);
+                        if (NULL == mydirent) {
+                                break;
+                        }
+                        memcpy(current_path_tail, mydirent->d_name, strlen(mydirent->d_name) + 1);
+                } while (!PathMatchSpecA(current_path, (char *)(dirp->payload)));
+                free(current_path);
+                if (NULL == mydirent) {
+                        errno = ENOENT;
+                        SetLastError(ERROR_NO_MORE_FILES);
+                        _doserrno = ERROR_NO_MORE_FILES;
+                        return 0;
+                }
+                mbstowcs_size = mbstowcs(lpFindFileData->cFileName, mydirent->d_name, sizeof(lpFindFileData->cFileName) / sizeof(lpFindFileData->cFileName[0]) - 1);
+                if ((size_t)-1 == mbstowcs_size) {
+                        errno = EIO;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+                lpFindFileData->cFileName[mbstowcs_size] = 0;
+                lpFindFileData->cAlternateFileName[0] = 0;
+                lpFindFileData->dwFileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+                return 1;
+        } else {
+                return FindNextFileW(
+                        hFindFile,
+                        lpFindFileData
+                );
+        }
+}
+
+BOOL
+EncloseIOFindClose(
+        HANDLE hFindFile
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFindFile);
+        int ret;
+
+	if (sqf) {
+                ret = squash_closedir((SQUASH_DIR *)hFindFile);
+                if (0 == ret) {
+                        return 1;
+                } else {
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+        } else {
+                return FindClose(
+                        hFindFile
+                );
+        }
+}
+
+BOOL
+EncloseIODeviceIoControl(
+        HANDLE hDevice,
+        DWORD dwIoControlCode,
+        LPVOID lpInBuffer,
+        DWORD nInBufferSize,
+        LPVOID lpOutBuffer,
+        DWORD nOutBufferSize,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hDevice);
+	int ret;
+
+	if (sqf) {
+		char the_path[SQUASHFS_PATH_LEN + 1];
+		wchar_t the_wpath[SQUASHFS_PATH_LEN + 1];
+		struct stat st;
+		size_t retlen;
+		REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*)lpOutBuffer;
+
+		// TODO handle the overlapped
+		assert(NULL == lpOverlapped);
+
+		// TODO support more than FSCTL_GET_REPARSE_POINT
+		assert(0 == nInBufferSize);
+
+		// FSCTL_GET_REPARSE_POINT
+		// https://msdn.microsoft.com/en-us/library/windows/desktop/aa364571(v=vs.85).aspx
+		assert(dwIoControlCode == FSCTL_GET_REPARSE_POINT);
+		assert(NULL == lpInBuffer);
+		st = sqf->st;
+		if (!S_ISLNK(st.st_mode)) {
+			errno = EINVAL;
+			SetLastError(ERROR_NOT_A_REPARSE_POINT);
+			_doserrno = ERROR_NOT_A_REPARSE_POINT;
+			return FALSE;
+		}
+		ret = squash_readlink_inode(
+			enclose_io_fs,
+			&sqf->node,
+			the_path,
+			SQUASHFS_PATH_LEN
+		);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+                
+		retlen = mbstowcs(the_wpath, the_path, SQUASHFS_PATH_LEN);
+		if ((size_t)-1 == retlen) {
+			errno = ENAMETOOLONG;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		the_wpath[retlen] = L'\0';
+		*lpBytesReturned = sizeof(REPARSE_DATA_BUFFER) + retlen * sizeof(wchar_t);
+		if (*lpBytesReturned > nOutBufferSize) {
+			*lpBytesReturned = 0;
+			errno = ENAMETOOLONG;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		reparse_data->ReparseTag = IO_REPARSE_TAG_SYMLINK;
+		memcpy(reparse_data->SymbolicLinkReparseBuffer.PathBuffer, the_wpath, (retlen + 1) * sizeof(wchar_t));
+		reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength = retlen * sizeof(wchar_t);
+		reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
+		return TRUE;
+	} else {
+		return DeviceIoControl(
+			hDevice,
+			dwIoControlCode,
+			lpInBuffer,
+			nInBufferSize,
+			lpOutBuffer,
+			nOutBufferSize,
+			lpBytesReturned,
+			lpOverlapped
+		);
+	}
+}
+
+HANDLE
+EncloseIOCreateIoCompletionPort(
+        HANDLE FileHandle,
+        HANDLE ExistingCompletionPort,
+        ULONG_PTR CompletionKey,
+        DWORD NumberOfConcurrentThreads
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)FileHandle);
+
+	if (sqf) {
+		// do nothing
+		assert(NULL != ExistingCompletionPort);
+		return ExistingCompletionPort;
+	} else {
+		return CreateIoCompletionPort(
+			FileHandle,
+			ExistingCompletionPort,
+			CompletionKey,
+			NumberOfConcurrentThreads
+		);
+	}
+}
+
+BOOL
+EncloseIOReadDirectoryChangesW(
+        HANDLE hDirectory,
+        LPVOID lpBuffer,
+        DWORD nBufferLength,
+        BOOL bWatchSubtree,
+        DWORD dwNotifyFilter,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped,
+        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hDirectory);
+
+	if (sqf) {
+		// do nothing
+		assert(lpOverlapped);
+		return TRUE;
+	} else {
+		return ReadDirectoryChangesW(
+			hDirectory,
+			lpBuffer,
+			nBufferLength,
+			bWatchSubtree,
+			dwNotifyFilter,
+			lpBytesReturned,
+			lpOverlapped,
+			lpCompletionRoutine
+		);
+	}
+}
+
+HMODULE
+EncloseIOLoadLibraryExW(
+	LPCWSTR lpLibFileName,
+	HANDLE hFile,
+	DWORD dwFlags
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpLibFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpLibFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			LoadLibraryExW(
+				squash_extract(enclose_io_fs, enclose_io_expanded, "dll"),
+				hFile,
+				dwFlags
+			),
+			LoadLibraryEx(
+				mkdir_workdir_expanded,
+				hFile,
+				dwFlags
+			)
+		);
+	}
+	else if (enclose_io_is_path_w(lpLibFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpLibFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			LoadLibraryExW(
+				squash_extract(enclose_io_fs, enclose_io_converted, "dll"),
+				hFile,
+				dwFlags
+			),
+			LoadLibraryEx(
+				mkdir_workdir_expanded,
+				hFile,
+				dwFlags
+			)
+		);
+	}
+	else {
+		return LoadLibraryExW(
+			lpLibFileName,
+			hFile,
+			dwFlags
+		);
+	}
+}
+
+BOOL
+EncloseIOCreateProcessW(
+	LPCWSTR lpApplicationName,
+	LPWSTR lpCommandLine,
+	LPSECURITY_ATTRIBUTES lpProcessAttributes,
+	LPSECURITY_ATTRIBUTES lpThreadAttributes,
+	BOOL bInheritHandles,
+	DWORD dwCreationFlags,
+	LPVOID lpEnvironment,
+	LPCWSTR lpCurrentDirectory,
+	LPSTARTUPINFOW lpStartupInfo,
+	LPPROCESS_INFORMATION lpProcessInformation
+)
+{
+	if (NULL != lpCurrentDirectory && enclose_io_is_path_w(lpCurrentDirectory)) {
+		lpCurrentDirectory = NULL;
+	}
+	return CreateProcessW(
+		lpApplicationName,
+		lpCommandLine,
+		lpProcessAttributes,
+		lpThreadAttributes,
+		bInheritHandles,
+		dwCreationFlags,
+		lpEnvironment,
+		lpCurrentDirectory,
+		lpStartupInfo,
+		lpProcessInformation
+	);
+}
+
+BOOL
+EncloseIOGetFileInformationByHandle(
+	HANDLE hFile,
+	LPBY_HANDLE_FILE_INFORMATION lpFileInformation
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFile);
+	struct stat st;
+	if (sqf) {
+		st = sqf->st;
+		lpFileInformation->dwFileAttributes = EncloseIOGetFileAttributesHelper(&st);
+		EncloseIOUnixtimeToFiletime(st.st_ctime, &lpFileInformation->ftCreationTime);
+		EncloseIOUnixtimeToFiletime(st.st_atime, &lpFileInformation->ftLastAccessTime);
+		EncloseIOUnixtimeToFiletime(st.st_mtime, &lpFileInformation->ftLastWriteTime);
+		lpFileInformation->dwVolumeSerialNumber = 0; // TODO
+		lpFileInformation->nFileSizeHigh = 0;
+		lpFileInformation->nFileSizeLow = st.st_size;
+		lpFileInformation->nNumberOfLinks = st.st_nlink;
+		lpFileInformation->nFileIndexHigh = 0;
+		lpFileInformation->nFileIndexLow = st.st_ino;
+		return 1;
+	} else {
+		return GetFileInformationByHandle(
+			hFile,
+			lpFileInformation
+		);
+	}
+}
+
+#ifndef RUBY_EXPORT
+NTSTATUS
+EncloseIOpNtQueryInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass)
+{
+	struct squash_file *sqf = squash_find_entry((void *)FileHandle);
+	struct stat st;
+	if (sqf) {
+		st = sqf->st;
+		IoStatusBlock->Status = STATUS_NOT_IMPLEMENTED;
+		FILE_ALL_INFORMATION *file_info = (FILE_ALL_INFORMATION *)FileInformation;
+		file_info->BasicInformation.FileAttributes = EncloseIOGetFileAttributesHelper(&st);
+		file_info->StandardInformation.EndOfFile.QuadPart = st.st_size;
+
+		file_info->BasicInformation.LastAccessTime.QuadPart = st.st_atime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.ChangeTime.QuadPart = st.st_mtime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.LastWriteTime.QuadPart = st.st_mtime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.CreationTime.QuadPart = st.st_ctime * 10000000ULL + 116444736000000000ULL;
+		file_info->InternalInformation.IndexNumber.QuadPart = st.st_ino;
+		file_info->StandardInformation.AllocationSize.QuadPart = st.st_size;
+		file_info->StandardInformation.NumberOfLinks = st.st_nlink;
+
+		return STATUS_SUCCESS;
+	} else {
+		return pNtQueryInformationFile(
+			FileHandle,
+			IoStatusBlock,
+			FileInformation,
+			Length,
+			FileInformationClass
+		);
+	}
+}
+
+NTSTATUS
+EncloseIOpNtQueryVolumeInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass)
+{
+	if (squash_find_entry((void *)FileHandle)) {
+		IoStatusBlock->Status = STATUS_NOT_IMPLEMENTED;
+		return STATUS_SUCCESS;
+	} else {
+		return pNtQueryVolumeInformationFile(
+			FileHandle,
+			IoStatusBlock,
+			FsInformation,
+			Length,
+			FsInformationClass);
+	}
+}
+
+NTSTATUS
+EncloseIOpNtQueryDirectoryFile(
+	HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+)
+{
+        SQUASH_DIR *handle;
+        struct SQUASH_DIRENT *mydirent;
+        size_t retlen;
+
+	if (squash_find_entry((void *)FileHandle)) {
+		handle = (SQUASH_DIR *)FileHandle;
+		mydirent = squash_readdir(handle);
+		if (NULL == mydirent) {
+			return STATUS_NO_MORE_FILES;
+		} else {
+                        /* FileInformation points to a buffer to hold directory entries.
+                         * It's important that this buffer can hold at least one entry, regardless
+                         * of the length of the file names present in the enumerated directory.
+                         * A file name is at most 256 WCHARs long.
+                         * According to MSDN, the buffer must be aligned at an 8-byte boundary.
+                         */
+                        assert(Length > 256 * sizeof(wchar_t));
+			FILE_DIRECTORY_INFORMATION *ret = (FILE_DIRECTORY_INFORMATION *)FileInformation;
+			ret->NextEntryOffset = 0;
+			retlen = mbstowcs(ret->FileName, mydirent->d_name, 255);
+			if ((size_t)-1 == retlen) {
+				return -1;
+                        }
+                        ret->FileName[retlen] = 0;
+                        ret->FileNameLength = sizeof(ret->FileName[0]) * retlen;
+			ret->FileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+                        IoStatusBlock->Information = (char*)(&ret->FileName[retlen]) - (char*)FileInformation + 1;
+			return STATUS_SUCCESS;
+		}
+	} else {
+		return pNtQueryDirectoryFile(
+			FileHandle,
+			Event,
+			ApcRoutine,
+			ApcContext,
+			IoStatusBlock,
+			FileInformation,
+			Length,
+			FileInformationClass,
+			ReturnSingleEntry,
+			FileName,
+			RestartScan
+		);
+	}
+}
+
+#endif // !RUBY_EXPORT
+#endif
diff --git a/ruby/enclose_io_win32.h b/ruby/enclose_io_win32.h
new file mode 100644
index 00000000..69e46754
--- /dev/null
+++ b/ruby/enclose_io_win32.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2017 - 2020 Minqi Pan <pmq2001@gmail.com>
+ *                           Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_WIN32_H_9A3D18C6
+#define ENCLOSE_IO_WIN32_H_9A3D18C6
+#ifndef __cplusplus
+#ifdef _WIN32
+
+#ifdef _fstati64
+#undef _fstati64
+#endif
+
+#define chdir(...)	enclose_io_chdir(__VA_ARGS__)
+
+#ifndef RUBY_EXPORT
+	// Ruby has defined the following symbols to
+	// something like rb_w32_uopen
+	#define getcwd(...)	enclose_io_getcwd(__VA_ARGS__)
+	#define stat(...)	enclose_io_stat(__VA_ARGS__)
+	#define fstat(...)	enclose_io_fstat(__VA_ARGS__)
+	#define open(...)	enclose_io_open(ENCLOSE_IO_PP_NARG(__VA_ARGS__), __VA_ARGS__)
+	#define close(...)	enclose_io_close(__VA_ARGS__)
+	#define read(...)	enclose_io_read(__VA_ARGS__)
+	#define lseek(...)	enclose_io_lseek(__VA_ARGS__)
+
+	// Ruby does not use those things
+	#define pNtQueryDirectoryFile(...) EncloseIOpNtQueryDirectoryFile(__VA_ARGS__)
+	#define pNtQueryInformationFile(...) EncloseIOpNtQueryInformationFile(__VA_ARGS__)
+	#define pNtQueryVolumeInformationFile(...) EncloseIOpNtQueryVolumeInformationFile(__VA_ARGS__)
+#endif // !RUBY_EXPORT
+
+#define _chdir(...) enclose_io_chdir(__VA_ARGS__)
+#define _wchdir(...) enclose_io_wchdir(__VA_ARGS__)
+#define _getwd(...) enclose_io_getwd(__VA_ARGS__)
+#define _wgetwd(...) enclose_io_wgetwd(__VA_ARGS__)
+#define _fstati64(...)	enclose_io_fstati64(__VA_ARGS__)
+#define _open(...)	enclose_io__open(__VA_ARGS__)
+#define _wopen(...)	enclose_io__wopen(__VA_ARGS__)
+#define _wmkdir(...) enclose_io__wmkdir(__VA_ARGS__)
+#define _close(...)	enclose_io_close(__VA_ARGS__)
+#define _open_osfhandle(...) enclose_io_open_osfhandle(__VA_ARGS__)
+#define _get_osfhandle(...) enclose_io_get_osfhandle(__VA_ARGS__)
+#define _read(...)	enclose_io_read(__VA_ARGS__)
+#define _lseeki64(...)	enclose_io_lseeki64(__VA_ARGS__)
+
+#define CreateFileW(...) EncloseIOCreateFileW(__VA_ARGS__)
+#define CloseHandle(...) EncloseIOCloseHandle(__VA_ARGS__)
+#define ReadFile(...) EncloseIOReadFile(__VA_ARGS__)
+
+#define GetFileAttributesW(...) EncloseIOGetFileAttributesW(__VA_ARGS__)
+#define GetFileAttributesExW(...) EncloseIOGetFileAttributesExW(__VA_ARGS__)
+#define GetHandleInformation(...) EncloseIOGetHandleInformation(__VA_ARGS__)
+#define GetFileType(...) EncloseIOGetFileType(__VA_ARGS__)
+#define FindFirstFileW(...) EncloseIOFindFirstFileW(__VA_ARGS__)
+#define FindNextFileW(...) EncloseIOFindNextFileW(__VA_ARGS__)
+#define FindClose(...) EncloseIOFindClose(__VA_ARGS__)
+#define DeviceIoControl(...) EncloseIODeviceIoControl(__VA_ARGS__)
+#define CreateIoCompletionPort(...) EncloseIOCreateIoCompletionPort(__VA_ARGS__)
+#define ReadDirectoryChangesW(...) EncloseIOReadDirectoryChangesW(__VA_ARGS__)
+#define LoadLibraryExW(...) EncloseIOLoadLibraryExW(__VA_ARGS__)
+#define CreateProcessW(...) EncloseIOCreateProcessW(__VA_ARGS__)
+#define SetCurrentDirectoryW(...) EncloseIOSetCurrentDirectoryW(__VA_ARGS__)
+#define GetCurrentDirectoryW(...) EncloseIOGetCurrentDirectoryW(__VA_ARGS__)
+#define GetFullPathNameW(...) EncloseIOGetFullPathNameW(__VA_ARGS__)
+#define GetFileInformationByHandle(...) EncloseIOGetFileInformationByHandle(__VA_ARGS__)
+
+#endif //_WIN32
+#endif //!__cplusplus
+#endif
diff --git a/ruby/enclose_io_winapi.h b/ruby/enclose_io_winapi.h
new file mode 100644
index 00000000..c27000d4
--- /dev/null
+++ b/ruby/enclose_io_winapi.h
@@ -0,0 +1,246 @@
+/*
+* Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+*                    Shengyuan Liu <sounder.liu@gmail.com>
+*
+* This file is part of libsquash, distributed under the MIT License
+* For full terms see the included LICENSE file
+*/
+
+#ifndef ENCLOSE_IO_WINAPI_H_VD6Y96RT
+#define ENCLOSE_IO_WINAPI_H_VD6Y96RT
+
+#ifndef STATUS_NO_MORE_FILES
+# define STATUS_NO_MORE_FILES ((NTSTATUS) 0x80000006L)
+#endif
+
+#ifndef STATUS_NOT_IMPLEMENTED
+# define STATUS_NOT_IMPLEMENTED ((NTSTATUS) 0xC0000002L)
+#endif
+
+#ifndef STATUS_SUCCESS
+# define STATUS_SUCCESS ((NTSTATUS) 0x00000000L)
+#endif
+
+typedef struct _IO_STATUS_BLOCK {
+	union {
+		NTSTATUS Status;
+		PVOID Pointer;
+	};
+	ULONG_PTR Information;
+} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
+
+typedef VOID (NTAPI *PIO_APC_ROUTINE)
+             (PVOID ApcContext,
+              PIO_STATUS_BLOCK IoStatusBlock,
+              ULONG Reserved);
+
+typedef enum _FILE_INFORMATION_CLASS {
+	FileDirectoryInformation = 1,
+	FileFullDirectoryInformation,
+	FileBothDirectoryInformation,
+	FileBasicInformation,
+	FileStandardInformation,
+	FileInternalInformation,
+	FileEaInformation,
+	FileAccessInformation,
+	FileNameInformation,
+	FileRenameInformation,
+	FileLinkInformation,
+	FileNamesInformation,
+	FileDispositionInformation,
+	FilePositionInformation,
+	FileFullEaInformation,
+	FileModeInformation,
+	FileAlignmentInformation,
+	FileAllInformation,
+	FileAllocationInformation,
+	FileEndOfFileInformation,
+	FileAlternateNameInformation,
+	FileStreamInformation,
+	FilePipeInformation,
+	FilePipeLocalInformation,
+	FilePipeRemoteInformation,
+	FileMailslotQueryInformation,
+	FileMailslotSetInformation,
+	FileCompressionInformation,
+	FileObjectIdInformation,
+	FileCompletionInformation,
+	FileMoveClusterInformation,
+	FileQuotaInformation,
+	FileReparsePointInformation,
+	FileNetworkOpenInformation,
+	FileAttributeTagInformation,
+	FileTrackingInformation,
+	FileIdBothDirectoryInformation,
+	FileIdFullDirectoryInformation,
+	FileValidDataLengthInformation,
+	FileShortNameInformation,
+	FileIoCompletionNotificationInformation,
+	FileIoStatusBlockRangeInformation,
+	FileIoPriorityHintInformation,
+	FileSfioReserveInformation,
+	FileSfioVolumeInformation,
+	FileHardLinkInformation,
+	FileProcessIdsUsingFileInformation,
+	FileNormalizedNameInformation,
+	FileNetworkPhysicalNameInformation,
+	FileIdGlobalTxDirectoryInformation,
+	FileIsRemoteDeviceInformation,
+	FileAttributeCacheInformation,
+	FileNumaNodeInformation,
+	FileStandardLinkInformation,
+	FileRemoteProtocolInformation,
+	FileMaximumInformation
+} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
+
+/* from winternl.h */
+typedef struct _UNICODE_STRING {
+	USHORT Length;
+	USHORT MaximumLength;
+	PWSTR  Buffer;
+} UNICODE_STRING, *PUNICODE_STRING;
+
+typedef NTSTATUS(NTAPI *sNtQueryDirectoryFile)
+(HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+	);
+
+typedef struct _FILE_DIRECTORY_INFORMATION {
+	ULONG NextEntryOffset;
+	ULONG FileIndex;
+	LARGE_INTEGER CreationTime;
+	LARGE_INTEGER LastAccessTime;
+	LARGE_INTEGER LastWriteTime;
+	LARGE_INTEGER ChangeTime;
+	LARGE_INTEGER EndOfFile;
+	LARGE_INTEGER AllocationSize;
+	ULONG FileAttributes;
+	ULONG FileNameLength;
+	WCHAR FileName[1];
+} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
+
+typedef NTSTATUS(NTAPI *sNtQueryInformationFile)
+(HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass);
+
+typedef enum _FS_INFORMATION_CLASS {
+	FileFsVolumeInformation = 1,
+	FileFsLabelInformation = 2,
+	FileFsSizeInformation = 3,
+	FileFsDeviceInformation = 4,
+	FileFsAttributeInformation = 5,
+	FileFsControlInformation = 6,
+	FileFsFullSizeInformation = 7,
+	FileFsObjectIdInformation = 8,
+	FileFsDriverPathInformation = 9,
+	FileFsVolumeFlagsInformation = 10,
+	FileFsSectorSizeInformation = 11
+} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
+
+typedef NTSTATUS(NTAPI *sNtQueryVolumeInformationFile)
+(HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass);
+
+typedef struct _FILE_BASIC_INFORMATION {
+	LARGE_INTEGER CreationTime;
+	LARGE_INTEGER LastAccessTime;
+	LARGE_INTEGER LastWriteTime;
+	LARGE_INTEGER ChangeTime;
+	DWORD FileAttributes;
+} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
+
+typedef struct _FILE_STANDARD_INFORMATION {
+	LARGE_INTEGER AllocationSize;
+	LARGE_INTEGER EndOfFile;
+	ULONG         NumberOfLinks;
+	BOOLEAN       DeletePending;
+	BOOLEAN       Directory;
+} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;
+
+typedef struct _FILE_INTERNAL_INFORMATION {
+	LARGE_INTEGER IndexNumber;
+} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;
+
+typedef struct _FILE_EA_INFORMATION {
+	ULONG EaSize;
+} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;
+
+typedef struct _FILE_ACCESS_INFORMATION {
+	ACCESS_MASK AccessFlags;
+} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;
+
+typedef struct _FILE_POSITION_INFORMATION {
+	LARGE_INTEGER CurrentByteOffset;
+} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;
+
+typedef struct _FILE_MODE_INFORMATION {
+	ULONG Mode;
+} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;
+
+typedef struct _FILE_ALIGNMENT_INFORMATION {
+	ULONG AlignmentRequirement;
+} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;
+
+typedef struct _FILE_NAME_INFORMATION {
+	ULONG FileNameLength;
+	WCHAR FileName[1];
+} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;
+
+typedef struct _FILE_ALL_INFORMATION {
+	FILE_BASIC_INFORMATION     BasicInformation;
+	FILE_STANDARD_INFORMATION  StandardInformation;
+	FILE_INTERNAL_INFORMATION  InternalInformation;
+	FILE_EA_INFORMATION        EaInformation;
+	FILE_ACCESS_INFORMATION    AccessInformation;
+	FILE_POSITION_INFORMATION  PositionInformation;
+	FILE_MODE_INFORMATION      ModeInformation;
+	FILE_ALIGNMENT_INFORMATION AlignmentInformation;
+	FILE_NAME_INFORMATION      NameInformation;
+} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;
+
+extern sNtQueryDirectoryFile pNtQueryDirectoryFile;
+extern sNtQueryInformationFile pNtQueryInformationFile;
+extern sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;
+
+typedef struct _REPARSE_DATA_BUFFER {
+        ULONG  ReparseTag;
+        USHORT ReparseDataLength;
+        USHORT Reserved;
+        union {
+                struct {
+                        USHORT SubstituteNameOffset;
+                        USHORT SubstituteNameLength;
+                        USHORT PrintNameOffset;
+                        USHORT PrintNameLength;
+                        ULONG Flags;
+                        WCHAR PathBuffer[1];
+                } SymbolicLinkReparseBuffer;
+                struct {
+                        USHORT SubstituteNameOffset;
+                        USHORT SubstituteNameLength;
+                        USHORT PrintNameOffset;
+                        USHORT PrintNameLength;
+                        WCHAR PathBuffer[1];
+                } MountPointReparseBuffer;
+                struct {
+                        UCHAR  DataBuffer[1];
+                } GenericReparseBuffer;
+        };
+} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
+
+#endif
-- 
2.24.3 (Apple Git-128)

